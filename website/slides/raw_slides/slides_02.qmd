---
title: "STAT 479 Lecture 2"
subtitle: "Expected Goals"
format: revealjs
execute: 
  cache: true
---

# Motivation & Outline

## Motivation: Beth Mead in EURO 2022
- Beth Mead scored 6 goals in EURO 2022. Which was more impressive?
  - Goal in 15th minute against Austria [link](https://youtube.com/clip/UgkxnOKsnw4W3h-BqV5kyh-tOVnnTgBEc9u5?si=zpQB7OF43gt3yiwK)
  - Goal in 37th minute against Norway [link](https://youtube.com/clip/UgkxqZ03bRBGCr4vS0M4yTMtHMOHsA6kkTHw?si=2IlC7AVi2CQotunG)
  - Goal in 33rd minute against Sweden [link](https://youtube.com/clip/UgkxwW9N1bXUv4G9HoSHVvYy_rk_aSjkrgwO?si=O90nkbgNd2FTv3e_)

. . .

- We can argue endlessly about *qualitative* differences
  - One-on-one vs in-traffic; left or right foot; 
  - Type of shot; time; score; ...
  
. . .

- Goal: **quantitative** comparison

## A Thought Experiment

- What if we could replay each shot over and over again?
- How often would she score?

![](mead_sweden.png){width="60%" fig-align="center"}

. . .

- This long-run frequency is Expected Goals (XG) 

# Soccer Event Data

## StatsBomb & Hudl
- Player location data for all events
  * Computer vision + input from 5 human annotators
  * Humans log events (shots, tackles, passes, etc.)
  * Computer vision to extra location information
- Locations mapped to fixed coordinate system
- **StatsBombR** package: available via GitHub
```{r}
#| label: install-statsbomb
#| eval: false
#| echo: true
devtools::install_github("statsbomb/StatsBombR")
```

## StatsBomb Coordinates

- Offensive action moves left-to-right
- Vertical coordinate increases as you move top-to-bottom

![StatsBomb Coordinates](statsbomb_coordinates.png){fig-asp=0.75, width="65%"}

## Free Competitions
- `FreeCompetitions()` returns table of available competitions
```{r}
#| label: statsbomb-free-comp
#| eval: true
#| echo: false
#| message: false
#| warning: false
set.seed(129)
StatsBombR::FreeCompetitions() |>
  dplyr::select(competition_id, season_id, 
                competition_name, season_name) |>
  dplyr::slice_sample(n=10)
```

## Free Matches{}
```{r}
#| label: view-euro2022-matches-code
#| message: false
#| warning: false
#| eval: false
#| echo: true
#| code-line-numbers: "|1|2|3|5"
StatsBombR::FreeCompetitions() |>
  dplyr::filter(competition_id == 53 & season_id == 106) |> 
  StatsBombR::FreeMatches() |>
  dplyr::select(match_id, home_team.home_team_name, away_team.away_team_name, home_score, away_score) |>
  dplyr::slice_sample(n=5)
```

. . .

```{r}
#| label: view-euro2022-matches-eval
#| message: false
#| warning: false
#| eval: true
#| echo: false
#| output: false
tmp <- StatsBombR::FreeCompetitions() |>
  dplyr::filter(competition_id == 53 & season_id == 106) |> 
  StatsBombR::FreeMatches() |>
  dplyr::select(match_id, home_team.home_team_name, away_team.away_team_name, home_score, away_score) 
```
```{r}
#| label: view-euro2022-matches-display
#| eval: true 
#| echo: false
tmp |> dplyr::slice_sample(n=5)
```

## Event Data

:::{.panel-tabset}

### Get EURO2022 Events
```{r}
#| label: get-euro2022-events
#| echo: true
#| eval: true
#| output: false
#| message: false
#| warning: false
#| code-line-numbers: "|2|3|4-6|"
euro2022_events <-
  StatsBombR::FreeCompetitions() |> 
  dplyr::filter(competition_id == 53 & season_id == 106) |> 
  StatsBombR::FreeMatches() |> 
  StatsBombR::free_allevents() |> 
  StatsBombR::allclean() |> 
  StatsBombR::get.opposingteam()
```  

### Extract All Shots
```{r}
#| label: get-euro2022-shots
#| eval: true
#| echo: true
euro2022_shots <-
  euro2022_events |>
  dplyr::filter(type.name == "Shot" & shot.body_part.name != "Other") |>
  dplyr::mutate(Y = ifelse(shot.outcome.name == "Goal", 1, 0))
```
:::



## Mead's Shots
```{r}
#| label: get-mead-shots
#| eval: true
#| echo: true
mead_shots <-
  euro2022_shots |>
  dplyr::filter(player.name == "Bethany Mead")

mead_shots |>
  dplyr::select(OpposingTeam, minute, shot.body_part.name, shot.technique.name, Y)
```

# Conditional Expectations

## Thought Experiment: Repeating Shots

- What proportion of repetitions result in goals?
- Across all repetitions, conditions kept the same

![](mead_sweden.png){width="60%" fig-align="center"}


## Setup & Notation
- Suppose our data set contains $n$ shots
- For shot $i = 1, \ldots, n,$ we observe
  - $Y_{i}$: indicator shot resutled in goal ($Y = 1$) or not ($Y = 0$)
  - $\boldsymbol{\mathbf{X}}_{i}$: vector of $p$ features about the shot
- Features could include things like
  - Body part used & shot technique
  - Dist. to nearest defenders


## Conditional Probability
- Assumption: data are a representative sample from an infinite *super-population* of shots
- Each shot in super-population characterized by pair $(\boldsymbol{\mathbf{X}}, Y)$
- Repeating shot with features $\boldsymbol{\mathbf{x}}$ equivalent to sampling from *slice* of super-population with $\boldsymbol{\mathbf{X}} = \boldsymbol{\mathbf{x}}.$

. . .

$$
\textrm{XG}(\boldsymbol{\mathbf{x}}) = \mathbb{E}[Y \vert \boldsymbol{\mathbf{X}} = \boldsymbol{\mathbf{x}}] = \mathbb{P}(Y = 1 \vert \boldsymbol{\mathbf{X}} = \boldsymbol{\mathbf{x}})
$$

# Two Basic XG Models

## Defining The Super-population

- Ultimate goal is to assess Mead's performance in EURO 2022
  - Focus on women's internationals
  - Focus on shots attempted w/ foot or head

:::{.panel-tabset}
### Get Events
```{r}
#| label: get-wi
#| eval: true
#| echo: true
#| warning: false
#| message: false
#| output: false
wi_events <-
  StatsBombR::FreeCompetitions() |> 
  dplyr::filter(competition_gender == "female" & competition_international) |>
  StatsBombR::FreeMatches() |> 
  StatsBombR::free_allevents() |> 
  StatsBombR::allclean() |>
  StatsBombR::get.opposingteam()
```

### Extract Shots
```{r}
#| label: wi-shots-foot
#| eval: true
#| echo: true
wi_shots <-
  wi_events |>
  dplyr::filter(type.name == "Shot" & shot.body_part.name != "Other") |>  
  dplyr::mutate(Y = ifelse(shot.outcome.name == "Goal", 1, 0))
```

:::


## Idealized Calculation
- Suppose our only feature is `shot.body_part.name`

```{r}
#| label: tabulate-body-part
#| eval: true
#| echo: false
table(wi_shots |> dplyr::pull(shot.body_part.name))
```

- If we could access infinite super-population, compute $\textrm{XG}(\text{right-footed shot})$ by
  - Forming subgroup containing only right-footed shots
  - Calculating proportion of goals score

## Practical Calculation
- Since we cannot access infinite super-population, we must **estimate** XG from data
- We do so by mimicking idealized calculation
  1. Divide data into subgroups based on `shot.body_part.name`
  2. Compute proportion of goals within subgroups
- Rely on **dplyr**'s `group_by()` functionality to do this

## Estimating XG(body part)

```{r}
#| label: wi-xg-body-code
#| eval: false
#| echo: true
#| code-line-numbers: "|3|4"
xg_model1 <-
  wi_shots |>
  dplyr::group_by(shot.body_part.name) |>
  dplyr::summarise(XG1 = mean(Y), n = dplyr::n())
xg_model1
```

. . .

```{r}
#| label: wi-xg-body-eval
#| eval: true
#| echo: false
xg_model1 <-
  wi_shots |>
  dplyr::group_by(shot.body_part.name) |>
  dplyr::summarise(XG1 = mean(Y), n = dplyr::n())
xg_model1
```



## Assessing Beth Mead's Performance
- Append XG estimates to `mead_shots` w/ `left_join`
- Based on bodypart, each goal is about equally impressive:
- Model suggests 11% of repeated shots would result in goals
```{r}
#| label: mead-xg-foot-code
#| echo: true
#| eval: true
#| code-line-numbers: "|2|3|4"
mead_shots <- mead_shots |>
  dplyr::left_join(y = xg_model1 |> dplyr::select(shot.body_part.name, XG1),
                   by = "shot.body_part.name")
```

. . .

```{r}
#| label: mead-xg-foot-select
mead_shots |> dplyr::slice(c(1,4,14)) |> 
  dplyr::select(OpposingTeam, minute, shot.body_part.name, Y, XG1)
```

## Accounting For Shot Technique
- Each goal was scored off a different type of shot
- What if we condition body part & shot technique?
```{r}
#| label: wi-tech
#| eval: true
#| echo: true
table(wi_shots |> dplyr::pull(shot.technique.name))
```

## New XG Estimates
:::{.panel-tabset}

### XG Estimates
```{r}
#| label: wi-xg-body-tech
#| eval: true
#| echo: true
#| code-line-numbers: "3|4|"
xg_model2 <-
  wi_shots |>
  dplyr::group_by(shot.body_part.name, shot.technique.name) |>
  dplyr::summarize(XG2 = mean(Y), n = dplyr::n(), .groups = "drop")
xg_model2 |> dplyr::arrange(dplyr::desc(XG2))
```

### Mead's Performance
```{r}
#| label: mead-xg-body-tech
#| eval: true
#| echo: true
mead_shots <-
  mead_shots |>
  dplyr::inner_join(
    y = xg_model2 |> dplyr::select(-n), 
    by = c("shot.body_part.name", "shot.technique.name"))

mead_shots |>
  dplyr::select(OpposingTeam, minute, shot.body_part.name, shot.technique.name, Y, XG2) |>
  dplyr::slice(c(1, 4, 14))
```
:::

## Accounting for more features{.smaller}
- Our 2-feature model is still too coarse
  - Doesn't account for distance of shot
  - Doesn't account for defenders and keeper
- StatsBomb records many more features about shots
```{r}
#| label: shot-features
#| echo: false
#| eval: true
shot_vars <- c("shot.type.name", 
    "shot.technique.name", "shot.body_part.name",
    "DistToGoal", "DistToKeeper", # dist. to keeper is distance from GK to goal
    "AngleToGoal", "AngleToKeeper",
    "AngleDeviation", 
    "avevelocity","density", "density.incone",
    "distance.ToD1", "distance.ToD2",
    "AttackersBehindBall", "DefendersBehindBall",
    "DefendersInCone", "InCone.GK", "DefArea")
shot_vars
```
- How can we adjust for these in our XG model?

## Digression: What is the cone?
- Cone: area between shot location & goalposts
<!-- visualize this; ideally with defenders on -->
```{r}
#| label: fig-mead-sweden
#| eval: true
#| echo: false
#| fig-asp: 0.667
#| fig-width: 8
#| fig-align: center
#| fig-caption: Only one defender and the goalkeeper are in the "cone"
shot <- mead_shots[14,]
ff <- shot$shot.freeze_frame[[1]]


# corners of pitch
top_left_corner <- c(0,0)
bot_left_corner <- c(0,80)
top_right_corner <- c(120,0)
bot_right_corner <- c(120, 80)

# endpoints of half-line
top_halfline <- c(60,0)
bot_halfline <- c(60, 80)

# corners of left penalty area
top_left_penl <- c(0, 18)
bot_left_penl <- c(0,62)
top_right_penl <- c(18,18)
bot_right_penl <- c(18,62)

# corners of left goalkeeper area
top_left_gkl <- c(0,30)
bot_left_gkl <- c(0,50)
top_right_gkl <- c(6,30)
bot_right_gkl <- c(6,50)

# left goal posts
top_postl <- c(0,36)
bot_postl <- c(0,44)

# corners of left net
top_left_netl <- c(-2,36)
bot_left_netl <- c(-2, 44)
top_right_netl <- c(0, 36)
bot_right_netl <- c(0,44)

# corners of right penalty area
top_left_penr <- c(102,18)
bot_left_penr <- c(102,62)
top_right_penr <- c(120,18)
bot_right_penr <- c(120,62)
# corners of right goal keeper's area
top_left_gkr <- c(114,30)
bot_left_gkr <- c(114,50)
top_right_gkr <- c(120,30)
bot_right_gkr <- c(120,50)
# right goal posts
top_postr <- c(120,36)
bot_postr <- c(120,44)
# corners of left net
top_left_netr <- c(120,36)
bot_left_netr <- c(120, 44)
top_right_netr <- c(122, 36)
bot_right_netr <- c(122,44)

# half-circles
left_halfcirc <-
  data.frame(x = 60 + 10*cos(seq(from = pi/2, to = 3*pi/2, length = 100)),
             y = 40 - 10 * sin(seq(from = pi/2, to = 3*pi/2, length = 100)))

right_halfcirc <-
  data.frame(x = 60 + 10*cos(seq(from =-pi/2, to = pi/2, length = 100)),
             y = 40 - 10 * sin(seq(from = -pi/2, to = pi/2, length = 100)))

# Now plot Mead's location
oi_colors <- palette.colors(palette = "Okabe-Ito")


par(mar = c(3,3,2,1), 
    mgp = c(1.8, 0.5, 0), 
    xpd = TRUE) # xpd allows plotting in margins
plot(1, type = "n",
     xlab = "", ylab = "",
     xaxt = "n", yaxt = "n", bty = "n",
     xlim = c(0,120), ylim = c(80,0))
# boundaries of pitch
rect(xleft = bot_left_corner[1], ybottom = bot_left_corner[2], 
     xright = top_right_corner[1], ytop = top_right_corner[2],
     col = adjustcolor(oi_colors[4], alpha.f = 0.5),
     border = "white", lwd = 2)
# left penalty area
rect(xleft = bot_left_penl[1], ybottom = bot_left_penl[2],
     xright = top_right_penl[1], ytop = top_right_penl[2],
     border = "white", lwd = 2)
# left goalkeeper's area
rect(xleft = bot_left_gkl[1], ybottom = bot_left_gkl[2],
     xright = top_right_gkl[1], ytop = top_right_gkl[2],
     border = "white", lwd = 2)
# left net
rect(xleft = bot_left_netl[1], ybottom = bot_left_netl[2],
     xright = top_right_netl[1], ytop = top_right_netl[2],
     border = oi_colors[9],
     lwd = 2)

# right penalty area
rect(xleft = bot_left_penr[1], ybottom = bot_left_penr[2],
     xright = top_right_penr[1], ytop = top_right_penr[2],
     border = "white", lwd = 2)
# right goalkeeper's area
rect(xleft = bot_left_gkr[1], ybottom = bot_left_gkr[2],
     xright = top_right_gkr[1], ytop = top_right_gkr[2],
     border = "white", lwd = 2)
# right net
rect(xleft = bot_left_netr[1], ybottom = bot_left_netr[2],
     xright = top_right_netr[1], ytop = top_right_netr[2],
     border = oi_colors[9], lwd = 2)
# half-line
lines(x = c(top_halfline[1], bot_halfline[1]),
      y = c(top_halfline[2], bot_halfline[2]),
      col = "white", lwd = 2)
# left half-circle 
lines(x = left_halfcirc$x, y = left_halfcirc$y, lwd = 2, col = "white")
# right half-circle
lines(x = right_halfcirc$x, y = right_halfcirc$y, lwd = 2, col = "white")

polygon(x = c(shot$location.x, top_postr[1], bot_postr[1], shot$location.x),
        y = c(shot$location.y, top_postr[2], bot_postr[2], shot$location.y),
        col = adjustcolor(oi_colors[6], alpha.f = 0.5),
        border = oi_colors[6])

points(shot$location.x, shot$location.y, 
       pch = 16, cex = 1.8, col = "white")

for(i in 1:nrow(ff)){
  points(ff$location[i][[1]][1], ff$location[i][[1]][2], pch = 16, cex = 1,
         col = ifelse(ff$teammate[i], "white", oi_colors[5]))
}
mtext("Beth Mead Goal Against Sweden", side = 3, line = 1)
mtext("Created with free data from StatsBomb\n https://github.com/statsbomb/open-data",
      side = 1, line = 1)
```

## Idealized Computation

- If we could access super-population, easy to condition on more features
  - Slice population along $\mathbf{\boldsymbol{x}}$
  - Compute proportion of goals among the slice with $\mathbf{\boldsymbol{X}} = \mathbf{\boldsymbol{x}}$

. . . 

- Can we mimic this with our observed data?

## Practical Challenges
- Adjust for body part, technique, and # defenders in cone
```{r}
wi_shots |>
  dplyr::group_by(shot.body_part.name, shot.technique.name, DefendersInCone) |>
  dplyr::summarise(XG = mean(Y), n = dplyr::n(), .groups = 'drop') |>
  dplyr::arrange(dplyr::desc(XG)) |>
  dplyr::slice(c(1:5, (dplyr::n()-4):dplyr::n()))
```


## Model-based XG
- "Binning-and-averaging" not viable w/ many features due to small sample sizes
- *Statistical models* overcome these challenges by "borrowing strength"
- $\textrm{XG}(\boldsymbol{\mathbf{x}})$ informed by shots with $\boldsymbol{\mathbf{X}} = \boldsymbol{\mathbf{x}}$ and $\boldsymbol{\mathbf{X}} \approx \boldsymbol{\mathbf{x}}$
- How a model "borrows strength" depends on its underlying assumptions

. . .  

- Several challenges: 
  - $\mathbf{\boldsymbol{X}}$ may be high-dimensional
  - $\textrm{XG}$ likely depends on many interactions
  - $\textrm{XG}$ likely highly non-linear
- StatsBomb has a proprietary model

## StatsBomb's XG Estimates
- `shot.statsbomb_xg` records proprietary XG estimate
- Goal against Sweden had smallest XG and is, therefore, the most impressive
```{r}
mead_shots |>
  dplyr::select(OpposingTeam, minute, XG1, XG2, shot.statsbomb_xg) |>
  dplyr::mutate(XG1 = round(XG1, digits = 3), XG2 = round(XG2, digits = 3), 
                shot.statsbomb_xg = round(shot.statsbomb_xg, digits = 3)) |>
  dplyr::slice(c(1,4,14))

```


# Goals Over Expected

## Did Mead Outperform Expectations?
- How to interpret the difference $Y_{i} - \textrm{XG}_{i}$ when it is
  - Large & positive
  - Large & negative
  - Close to 0

. . .

- Beth Mead scored 2.89 more goals than expected
```{r}
#| label: mead-goe
#| eval: true
#| echo: true
sum(mead_shots$Y - mead_shots$shot.statsbomb_xg)
```

## Assessing All EURO2022 Players
```{r}
#| label: euro2022-goe
#| echo: true
#| eval: true

goe <- 
  euro2022_shots |>
  dplyr::mutate(diff = Y - shot.statsbomb_xg) |>
  dplyr::group_by(player.name) |>
  dplyr::summarise(GOE = sum(diff), Goals = sum(Y), n_shots = dplyr::n()) |>
  dplyr::arrange(dplyr::desc(GOE)) 
goe |> dplyr::slice(c(1:5, (dplyr::n()-4):dplyr::n()))


```

## Looking Ahead
- I **Strongly** recommend you work through code yourself
  - Full code available [here](../../lectures/lecture02.qmd)
  - Try more binning-and-averaging XG estimates w/ other features
  - Try to replicate goals over expected with EURO 2025 data
