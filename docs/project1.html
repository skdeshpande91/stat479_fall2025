<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Project 1 Information – STAT479</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-4bfb630b09c0e164834af1bb3207dbff.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">STAT479</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./syllabus.html"> 
<span class="menu-text">Syllabus</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-lecture-notes" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Lecture Notes</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-lecture-notes">    
        <li>
    <a class="dropdown-item" href="./lectures/lecture00.html">
 <span class="dropdown-text">Lecture 0: Boxscore Metrics</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./lectures/lecture02.html">
 <span class="dropdown-text">Lecture 2: Expected Goals</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./lectures/lecture03.html">
 <span class="dropdown-text">Lecture 3: Estimating XG</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./lectures/lecture04.html">
 <span class="dropdown-text">Lecture 4: Adjusted Plus/Minus</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./lectures/lecture05.html">
 <span class="dropdown-text">Lecture 5: Regularized Adjusted Plus/Minus</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./lectures/lecture06.html">
 <span class="dropdown-text">Lecture 6: Run Expectancy</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./lectures/lecture07.html">
 <span class="dropdown-text">Lecture 7: Offensive Credit Allocation in Baseball</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./lectures/lecture08.html">
 <span class="dropdown-text">Lecture 8: Defensive Credit Allocation in Baseball</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./lectures/lecture09.html">
 <span class="dropdown-text">Lecture 9: Multilevel Modeling</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./lectures/lecture10.html">
 <span class="dropdown-text">Lecture 10: NFl WAR</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./lectures/lecture11.html">
 <span class="dropdown-text">Lecture 11: Pitch Framing</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./lectures/lecture12.html">
 <span class="dropdown-text">Lecture 12: Power Rankings I</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./lectures/lecture13.html">
 <span class="dropdown-text">Lecture 13: Power Rankings II</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-lecture-slides" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Lecture Slides</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-lecture-slides">    
        <li>
    <a class="dropdown-item" href="./slides/lecture01.html">
 <span class="dropdown-text">Lecture 1</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./slides/lecture02.html">
 <span class="dropdown-text">Lecture 2: Expected Goals</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./slides/lecture03.html">
 <span class="dropdown-text">Lecture 3: Estimating XG</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./slides/lecture04.html">
 <span class="dropdown-text">Lecture 4: Adjusted Plus/Minus</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./slides/lecture05.html">
 <span class="dropdown-text">Lecture 5: Regularized Adjusted Plus/Minus</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./slides/lecture06.html">
 <span class="dropdown-text">Lecture 6: Expected Runs</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./slides/lecture07.html">
 <span class="dropdown-text">Lecture 7: Offensive Credit</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./slides/lecture08.html">
 <span class="dropdown-text">Lecture 8: Defensive Credit Allocation &amp; WAR</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link active" href="./project1.html" aria-current="page"> 
<span class="menu-text">Project 1 Information</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#overivew" id="toc-overivew" class="nav-link active" data-scroll-target="#overivew">Overivew</a></li>
  <li><a href="#deliverables" id="toc-deliverables" class="nav-link" data-scroll-target="#deliverables">Deliverables</a>
  <ul class="collapse">
  <li><a href="#written-report" id="toc-written-report" class="nav-link" data-scroll-target="#written-report">Written Report</a></li>
  <li><a href="#presentation" id="toc-presentation" class="nav-link" data-scroll-target="#presentation">Presentation</a></li>
  </ul></li>
  <li><a href="#potential-topics" id="toc-potential-topics" class="nav-link" data-scroll-target="#potential-topics">Potential Topics</a>
  <ul class="collapse">
  <li><a href="#develop-a-new-metric" id="toc-develop-a-new-metric" class="nav-link" data-scroll-target="#develop-a-new-metric">Develop a New Metric</a></li>
  <li><a href="#a-more-refined-xg-model-for-soccer" id="toc-a-more-refined-xg-model-for-soccer" class="nav-link" data-scroll-target="#a-more-refined-xg-model-for-soccer">A More Refined XG Model for Soccer</a></li>
  <li><a href="#expected-goals-in-hockey" id="toc-expected-goals-in-hockey" class="nav-link" data-scroll-target="#expected-goals-in-hockey">Expected Goals in Hockey</a></li>
  <li><a href="#nba-heatmaps-expected-points" id="toc-nba-heatmaps-expected-points" class="nav-link" data-scroll-target="#nba-heatmaps-expected-points">NBA Heatmaps &amp; Expected Points</a></li>
  <li><a href="#war-for-college-football-and-volleyball" id="toc-war-for-college-football-and-volleyball" class="nav-link" data-scroll-target="#war-for-college-football-and-volleyball">WAR For College Football and Volleyball</a></li>
  <li><a href="#adjusted-plusminus-for-college-basketball" id="toc-adjusted-plusminus-for-college-basketball" class="nav-link" data-scroll-target="#adjusted-plusminus-for-college-basketball">Adjusted Plus/Minus for College Basketball</a></li>
  <li><a href="#extending-ideas-from-baseball-to-cricket" id="toc-extending-ideas-from-baseball-to-cricket" class="nav-link" data-scroll-target="#extending-ideas-from-baseball-to-cricket">Extending Ideas from Baseball to Cricket</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Project 1 Information</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overivew" class="level2">
<h2 class="anchored" data-anchor-id="overivew">Overivew</h2>
<p>For your first project, I would like you to use publicly available play-by-play, event-level, or tracking data to assess player or team performance or decision-making. That is, your analysis should be based on data that is more granular than match- or game-level (e.g., box score, tables of seasonal totals, etc.) The project report and recorded presentation are due on <strong>Friday October 10 at 12:00pm (noon)</strong>.</p>
</section>
<section id="deliverables" class="level2">
<h2 class="anchored" data-anchor-id="deliverables">Deliverables</h2>
<section id="written-report" class="level3">
<h3 class="anchored" data-anchor-id="written-report">Written Report</h3>
<p>The written report consists of a non-technical executive summary and a technical report. The executive summary, which should not exceed 500 words, should describe the overall goals, analytic approach, and main conclusions in non-technical language. The executive summary should be free from jargon, code listings, figures, tables, and charts. It should be written to be read and understood by a front office executive, coach, player, or fan with little data science experience. The rest of written report should</p>
<ul>
<li>Clearly state the problem being studied and provide sufficient background details and to motivate why the problem is important and interesting.</li>
<li>Describe the data and major steps of the analysis</li>
<li>Presents the main results within the context of the relevant sport(s) and supports the results with figures, tables, charts, and other statistical software output as appropriate.</li>
<li>Discusses the limitations of the analysis and outlines concrete steps for further development.</li>
</ul>
<p>The technical section of the report should contain enough detail and code that another data scientist could replicate your analysis verify its soundness. Code listings and output (e.g., figures, tables, charts, and numerical summaries) should be tightly integrated with the written exposition. A good example of such integration is <a href="https://github.com/danmorse314/hockeyR-models">here</a>. Pay particular attention to the way the author complements the numerical results with detailed examples of individual performances.</p>
</section>
<section id="presentation" class="level3">
<h3 class="anchored" data-anchor-id="presentation">Presentation</h3>
<p>Each team will also record an 8–10 minute presentation (e.g., using Zoom) that provides an overview of their analysis. Each presentation should include the following elements</p>
<ul>
<li>Background (2–4 slides): clearly motivate and state the main problem being studied. Explain why it is interesting and important. Present just enough background to motivate the problem, while taking care not to overwhelm the audience with extraneous details. If appropriate, comment on the limitations of existing solutions to the problem or closely-related problems</li>
<li>Analysis overview (2–4 slides): present only the main steps of your analysis. Be sure to explain why each step was necessary and how these steps contribute to the overall solution. Focus more on the high-level ideas and motivation for each step rather than the specific implementation or software syntax</li>
<li>Main results (2–3 slides): distill your results into a few key points. Use figures, tables, charts, and other statistical software output to support your findings.</li>
<li>Conclusion (1 slide): briefly summarize your analysis and findings and outline between 1 and 3 specific directions for future development, improvement or refinement.</li>
</ul>
<p><strong>Every group member must speak during the presentation</strong>. I encourage you practice a few times to ensure smooth transitions between speakers.</p>
</section>
</section>
<section id="potential-topics" class="level2">
<h2 class="anchored" data-anchor-id="potential-topics">Potential Topics</h2>
<p>For your first project, you could extend or modify an analysis presented in class or one of the Exercises listed in the lecture notes. Here are some other potential project ideas. Note, these are merely suggestions and you are free to develop projects outside this list. If you would like additional inspiration, check out the papers from the Reproducible Research Competition from last year’s <a href="https://www.stat.cmu.edu/cmsac/conference/2024/">CMU Sports Analytics Conference</a>. The only requirement is that you (i) carefully assess player or team performance and (ii) utilize data at the play- or event-level (or finer).</p>
<section id="develop-a-new-metric" class="level3">
<h3 class="anchored" data-anchor-id="develop-a-new-metric">Develop a New Metric</h3>
<p>Using play-by-play or event-level data, construct a new measure of player or team skill. If you pursue this option, please take care to motivate the development of your new metric and to state, precisely, what the metric aims to quantify. You should explore its operating characteristics including (but certainly not limited to) its stability across games or seasons; its ability to predict season-level outcomes; the extent to which you are measuring a latent skill or ability; and its relationship to existing metrics. You should also explain how your new metric overcomes any limitations of existing metrics and discuss any drawbacks your metric might have. Finally, you should discuss how players, teams, or fans might use your new metric. Note: simply creating a new measure and ranking players according is <strong>not</strong> sufficient.</p>
</section>
<section id="a-more-refined-xg-model-for-soccer" class="level3">
<h3 class="anchored" data-anchor-id="a-more-refined-xg-model-for-soccer">A More Refined XG Model for Soccer</h3>
<p>In <a href="./lectures/lecture03.html">Lecture 3</a>, we built a random forests model to estimate the probability of a shot resulting in a goal using many features created by StatsBomb. While this model seemed much more accurate than simpler, parametric models, there is still much room for improvement. For your project, you can continue to develop more complex XG model. Here are some potential directions</p>
<ul>
<li>Intuitively, we might expect XG to be monotonic in certain features (e.g., the further away a shot is from the goal, the lower the XG). Unfortunately, random forests does not allow for monotonic constraints. XGBoost is another tree ensemble method that allows for monotonicity. Explore the use of XGBoost to estimate expected goals.</li>
<li>Our random forest model did not use the exact player locations as features. Intuitively, we might expect XG to vary smoothly in shot location. But if you simply include <code>location.x</code> and <code>location.y</code> as features, the resulting XG is not a smooth function. Explore the use of generalized additive models for creating smoother XG models.</li>
</ul>
<p>If you pursue this option, you should build at least 3 different XG models, compare them both quantitatively and qualitatively, and use the “best” model predictions to make a conclusion about player or team performance. At a minimum, you should establish which model is most predictive. But a more ambitious project will draw insights from differences between each models’ predctios<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. If you pursue this option, you should StatsBomb data from at least 3 competitions with more than a handful of match data available.</p>
</section>
<section id="expected-goals-in-hockey" class="level3">
<h3 class="anchored" data-anchor-id="expected-goals-in-hockey">Expected Goals in Hockey</h3>
<p>The package <a href="https://hockeyr.netlify.app"><strong>hockeyR</strong></a> provides functions for scraping play-by-play data from the National Hockey League. Among many other things, these data include shot distance, shot angle, and the coordinates of each shot. Using ideas from <a href="./lectures/lecture03.html">Lecture 3</a>, develop an XG model for hockey. If you puruse this option, you should build at least 3 different XG models, compare them both quantaitively and qualitatively, and use the “best” model to make conclusions about player or team performance. You can also compare your model predictions to those provided by the package itself.</p>
</section>
<section id="nba-heatmaps-expected-points" class="level3">
<h3 class="anchored" data-anchor-id="nba-heatmaps-expected-points">NBA Heatmaps &amp; Expected Points</h3>
<p>In Lectures <a href="./lectures/lecture04.html">4</a> and <a href="./lectures/lecture05.html">5</a>, we used the <a href="https://hoopr.sportsdataverse.org"><strong>hoopR</strong></a> package to scrape NBA play-by-play data, which we then used to estimate adjusted plus/minus. This package also includes shot location data. Using these data (and possibly other contextual information about the game state and player), build a model to predict the probability that a player makes a shot. Once built, use the model to compare player performance. For instance, you can convert these probabilities to expected points and explore how closely a player’s total expected points tracks the actual points score. Or you could identify players who score substantially more or less points than what a league-average or replacement-level player might be expected to score given the same shot selection.</p>
<p>If you puruse this option, you should build and compare at least 3 different models of shot selection. You should then select the “best” model using both qualitative and quantitative considerations.</p>
</section>
<section id="war-for-college-football-and-volleyball" class="level3">
<h3 class="anchored" data-anchor-id="war-for-college-football-and-volleyball">WAR For College Football and Volleyball</h3>
<p>In <a href="./lectures/lecture10.html">Lecture 10</a>, we used the <a href="https://www.nflfastr.com"><strong>nflfastR</strong></a> package to scrap play-by-play data from the National Football League. We then used these data to develop a version of Wins Above Replacement for offensive players in the NFL. The package <a href="https://cfbfastr.sportsdataverse.org"><strong>cfbfastR</strong></a> provides similar functinoality for college football. You could try to develop a version of WAR for college football. If you pursue this option, you must carefully deal with the differences between conferences when estimating individual player skills and defining replacement-level.</p>
<p>The package <a href="https://github.com/JeffreyRStevens/ncaavolleyballr"><strong>ncaavolleyballr</strong></a> provides functions to scrape NCAA Volleyball data<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, including play-by-play logs. Each row in the play-by-play data table correspond to individual events within a point (e.g., a serve, set, attack, kill, etc.) Using these data, develop a version of wins above replacement. To do this, you must first define and estimate an analog of runs value and expected points. Then, you must carefully divide this “currency” among players of different positions (e.g., middle blocker, libero, outside hitter, etc.). If you pursue this option, I highly recommend using the pre-scraped play-by-play data available <a href="https://jeffreyrstevens.github.io/ncaavolleyballr/articles/data.html">here</a> and then accessing player- and team-specific information (e.g., rosters, schedules, season-level statistics) using the package functions.</p>
</section>
<section id="adjusted-plusminus-for-college-basketball" class="level3">
<h3 class="anchored" data-anchor-id="adjusted-plusminus-for-college-basketball">Adjusted Plus/Minus for College Basketball</h3>
<p>The <a href="https://github.com/lbenz730/ncaahoopR"><strong>ncaahoopR</strong></a> package provides functions for scraping play-by-play data from college basketball. Using a workflow similar to the one presented in <a href="./lectures/lecture04.html">Lecture 4</a>, convert these data into stint-level data and develop a version of weighted and/or regularized adjusted plus/minus for college basketball.</p>
</section>
<section id="extending-ideas-from-baseball-to-cricket" class="level3">
<h3 class="anchored" data-anchor-id="extending-ideas-from-baseball-to-cricket">Extending Ideas from Baseball to Cricket</h3>
<p>The package <a href="https://pkg.robjhyndman.com/cricketdata/"><strong>cricketdata</strong></a> provides functions for scraping match-level data from (ESPNCricinfo)[https://www.espncricinfo.com]. <a href="https://himanishganjoo.com">Himanish Ganjoo</a> also provides very detailed ball-by-ball data for a large number of test, one-day international, and T20 matches <a href="https://himanishganjoo.com/cricket-data/">here</a>. You could consider building analogs of expected runs (e.g., as a function of wickets in hand and overs left) or building a model to predict the outcome of an individual ball given its line and length information. An even more ambitous project would develop a version of WAR for batting performance.</p>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>See the section “Benefiting from training several variants of the model” in <a href="https://www.hudl.com/blog/upgrading-expected-goals">this blogpost</a> from Hudl for some inspiration.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Note that there is another <a href="https://github.com/tyler-widdison/ncaavolleyballR">package</a> with similar functionality and an almost identical name (note the uppercase “R”).<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
        for (let i=0; i<annoteTargets.length; i++) {
          const annoteTarget = annoteTargets[i];
          const targetCell = annoteTarget.getAttribute("data-target-cell");
          const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
          const contentFn = () => {
            const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
            if (content) {
              const tipContent = content.cloneNode(true);
              tipContent.classList.add("code-annotation-tip-content");
              return tipContent.outerHTML;
            }
          }
          const config = {
            allowHTML: true,
            content: contentFn,
            onShow: (instance) => {
              selectCodeLines(instance.reference);
              instance.reference.classList.add('code-annotation-active');
              window.tippy.hideAll();
            },
            onHide: (instance) => {
              unselectCodeLines();
              instance.reference.classList.remove('code-annotation-active');
            },
            maxWidth: 300,
            delay: [50, 0],
            duration: [200, 0],
            offset: [5, 10],
            arrow: true,
            appendTo: function(el) {
              return el.parentElement.parentElement.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'quarto',
            placement: 'right',
            popperOptions: {
              modifiers: [
              {
                name: 'flip',
                options: {
                  flipVariations: false, // true by default
                  allowedAutoPlacements: ['right'],
                  fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
                },
              },
              {
                name: 'preventOverflow',
                options: {
                  mainAxis: false,
                  altAxis: false
                }
              }
              ]        
            }      
          };
          window.tippy(annoteTarget, config); 
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>