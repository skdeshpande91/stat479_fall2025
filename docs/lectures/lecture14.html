<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Lecture 14: Markov Chains I – STAT479</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-4bfb630b09c0e164834af1bb3207dbff.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">STAT479</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../syllabus.html"> 
<span class="menu-text">Syllabus</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-lecture-notes" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Lecture Notes</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-lecture-notes">    
        <li>
    <a class="dropdown-item" href="../lectures/lecture00.html">
 <span class="dropdown-text">Lecture 0: Boxscore Metrics</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/lecture02.html">
 <span class="dropdown-text">Lecture 2: Expected Goals</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/lecture03.html">
 <span class="dropdown-text">Lecture 3: Estimating XG</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/lecture04.html">
 <span class="dropdown-text">Lecture 4: Adjusted Plus/Minus</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/lecture05.html">
 <span class="dropdown-text">Lecture 5: Regularized Adjusted Plus/Minus</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/lecture06.html">
 <span class="dropdown-text">Lecture 6: Run Expectancy</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/lecture07.html">
 <span class="dropdown-text">Lecture 7: Offensive Credit Allocation in Baseball</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/lecture08.html">
 <span class="dropdown-text">Lecture 8: Defensive Credit Allocation in Baseball</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/lecture09.html">
 <span class="dropdown-text">Lecture 9: Multilevel Modeling</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/lecture10.html">
 <span class="dropdown-text">Lecture 10: NFl WAR</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/lecture11.html">
 <span class="dropdown-text">Lecture 11: Pitch Framing</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/lecture12.html">
 <span class="dropdown-text">Lecture 12: Bradley-Terry Models</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/lecture13.html">
 <span class="dropdown-text">Lecture 13: Tournament Simulation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/lecture14.html">
 <span class="dropdown-text">Lecture 14: Markov Chains I</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/lecture15.html">
 <span class="dropdown-text">Lecture 15: Markov Chains II</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/lecture16.html">
 <span class="dropdown-text">Lecture 16: Plackett-Luce Models</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../lectures/lecture17.html">
 <span class="dropdown-text">Lecture 17: NFL Drive Simulation</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-lecture-slides" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Lecture Slides</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-lecture-slides">    
        <li>
    <a class="dropdown-item" href="../slides/lecture01.html">
 <span class="dropdown-text">Lecture 1</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../slides/lecture02.html">
 <span class="dropdown-text">Lecture 2: Expected Goals</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../slides/lecture03.html">
 <span class="dropdown-text">Lecture 3: Estimating XG</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../slides/lecture04.html">
 <span class="dropdown-text">Lecture 4: Adjusted Plus/Minus</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../slides/lecture05.html">
 <span class="dropdown-text">Lecture 5: Regularized Adjusted Plus/Minus</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../slides/lecture06.html">
 <span class="dropdown-text">Lecture 6: Expected Runs</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../slides/lecture07.html">
 <span class="dropdown-text">Lecture 7: Offensive Credit</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../slides/lecture08.html">
 <span class="dropdown-text">Lecture 8: Defensive Credit Allocation &amp; WAR</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../slides/lecture09.html">
 <span class="dropdown-text">Lecture 9: Multilevel Models</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../slides/lecture10.html">
 <span class="dropdown-text">Lecture 10: NFL WAR</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../slides/lecture11.html">
 <span class="dropdown-text">Lecture 11: Pitch Framing</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../slides/lecture12.html">
 <span class="dropdown-text">Lecture 12: Bradley-Terry Models I</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../slides/lecture13.html">
 <span class="dropdown-text">Lecture 13: Bradley-Terry Models II</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../slides/lecture14.html">
 <span class="dropdown-text">Lecture 14: Markov Chains I</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../slides/lecture15.html">
 <span class="dropdown-text">Lecture 15: Markov Chains II</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../slides/lecture16.html">
 <span class="dropdown-text">Lecture 16: Plackett-Luce Models</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../slides/lecture17.html">
 <span class="dropdown-text">Lecture 17</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../slides/lecture24.html">
 <span class="dropdown-text">Lecture 24</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../project1.html"> 
<span class="menu-text">Project 1 Information</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../project2.html"> 
<span class="menu-text">Project 2 Information</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../project3.html"> 
<span class="menu-text">Project 3 Information</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../lectures/lecture14.html">Lecture 14: Markov Chains I</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/lecture00.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 0: Boxscore Metrics</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/lecture02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 2: Expected Goals</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/lecture03.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 3: Estimating XG</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/lecture04.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 4: Adjusted Plus/Minus</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/lecture05.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 5: Regularized Adjusted Plus/Minus</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/lecture06.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 6: Run Expectancy</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/lecture07.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 7: Offensive Credit Allocation in Baseball</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/lecture08.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 8: Defensive Credit Allocation in Baseball</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/lecture09.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 9: Multilevel Modeling</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/lecture10.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 10: NFl WAR</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/lecture11.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 11: Pitch Framing</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/lecture12.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 12: Bradley-Terry Models</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/lecture13.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 13: Tournament Simulation</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/lecture14.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Lecture 14: Markov Chains I</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/lecture15.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 15: Markov Chains II</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/lecture16.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 16: Plackett-Luce Models</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/lecture17.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 17: NFL Drive Simulation</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#sec-overview" id="toc-sec-overview" class="nav-link active" data-scroll-target="#sec-overview">Overview</a>
  <ul class="collapse">
  <li><a href="#sec-data-prep" id="toc-sec-data-prep" class="nav-link" data-scroll-target="#sec-data-prep">Data Preparation</a></li>
  </ul></li>
  <li><a href="#sec-markov-chain" id="toc-sec-markov-chain" class="nav-link" data-scroll-target="#sec-markov-chain">Markov Chains</a>
  <ul class="collapse">
  <li><a href="#sec-two-state" id="toc-sec-two-state" class="nav-link" data-scroll-target="#sec-two-state">Example: A 2-state Markov Chain</a></li>
  </ul></li>
  <li><a href="#a-graphical-perspective" id="toc-a-graphical-perspective" class="nav-link" data-scroll-target="#a-graphical-perspective">A Graphical Perspective</a>
  <ul class="collapse">
  <li><a href="#absorbing-states" id="toc-absorbing-states" class="nav-link" data-scroll-target="#absorbing-states">Absorbing States</a></li>
  <li><a href="#sec-three-state" id="toc-sec-three-state" class="nav-link" data-scroll-target="#sec-three-state">Example: Simulating Time to Absorption</a></li>
  </ul></li>
  <li><a href="#sec-half-inning" id="toc-sec-half-inning" class="nav-link" data-scroll-target="#sec-half-inning">A Markov Chain Model for Half-Innings</a>
  <ul class="collapse">
  <li><a href="#sec-estimate-transitions" id="toc-sec-estimate-transitions" class="nav-link" data-scroll-target="#sec-estimate-transitions">Estimating Transition Probabilities</a></li>
  <li><a href="#sec-simulation" id="toc-sec-simulation" class="nav-link" data-scroll-target="#sec-simulation">Simulating a Half-Inning</a></li>
  <li><a href="#sec-halfinning-length" id="toc-sec-halfinning-length" class="nav-link" data-scroll-target="#sec-halfinning-length">Length of a Half-Inning</a></li>
  <li><a href="#sec-runs-scored" id="toc-sec-runs-scored" class="nav-link" data-scroll-target="#sec-runs-scored">Runs Scored in a Half-Inning</a></li>
  </ul></li>
  <li><a href="#sec-nstep" id="toc-sec-nstep" class="nav-link" data-scroll-target="#sec-nstep">Modeling Multiple Steps</a></li>
  <li><a href="#sec-absorbing" id="toc-sec-absorbing" class="nav-link" data-scroll-target="#sec-absorbing">Theory of Absorbing Markov Chains</a></li>
  <li><a href="#sec-looking-ahead" id="toc-sec-looking-ahead" class="nav-link" data-scroll-target="#sec-looking-ahead">Looking Ahead</a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises">Exercises</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lecture 14: Markov Chains I</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="sec-overview" class="level2">
<h2 class="anchored" data-anchor-id="sec-overview">Overview</h2>
<p>In <a href="../lectures/lecture06.html">Lecture 6</a>, we introduced a state-based representation of baseball: each half-inning consists of several at-bats, each of which can be characterized by (i) the number of outs and (ii) configuration of the base-runners. We then estimated the expected number of runs that team can expect to score following at-bats that begin in each of the 24 combinations of outs and base-runner configurations. Today, we will focus less on evaluating what happens in each at-bat (e.g., using run expectancy or run value) and more on how the game transitions from state-to-state.</p>
<p>To motivate our work, let’s reconsider our running example from <a href="../lectures/lecture06.html">Lecture 6</a>, the March 20, 2024 game between the Dodgers and Padres. Specifically, let’s load the table <code>atbat2024</code> created in <a href="../lectures/lecture07.html">Lecture 7</a> and look at the sequence of game states that the Dodgers visited during the 8th inning.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">load</span>(<span class="st">"atbat2024.RData"</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>dodgers_inning <span class="ot">&lt;-</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  atbat2024 <span class="sc">|&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">filter</span>(game_pk <span class="sc">==</span> <span class="dv">745444</span> <span class="sc">&amp;</span> inning <span class="sc">==</span> <span class="dv">8</span> <span class="sc">&amp;</span> inning_topbot <span class="sc">==</span> <span class="st">"Top"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>dodgers_inning <span class="sc">|&gt;</span> dplyr<span class="sc">::</span><span class="fu">select</span>(at_bat_number, Outs, BaseRunner, end_events, end_Outs, end_BaseRunner)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 8 × 6
  at_bat_number  Outs BaseRunner end_events      end_Outs end_BaseRunner
          &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;              &lt;dbl&gt; &lt;chr&gt;         
1            59     0 000        walk                   0 100           
2            60     0 100        single                 0 110           
3            61     0 110        walk                   0 111           
4            62     0 111        sac_fly                1 110           
5            63     1 110        fielders_choice        1 110           
6            64     1 110        single                 1 110           
7            65     1 110        single                 1 110           
8            66     1 110        double_play            3 &lt;NA&gt;          </code></pre>
</div>
</div>
<p>We see that the inning consisted of 8 at-bats. During the first at-bat, in which Max Muncy was walked, the game transitioned from the state <code>0.000</code> (i.e., no outs and no runners on base) to the state <code>0.100</code> (i.e., no outs and a runner on 1st). During the 6th at-bat, when Mookie Betts drove in a run off a single, the game state did not change: at the beginning and end of the at-bat there was 1 out and runners on 1st and 2nd base.</p>
<p>If we were to replay this half-inning over and over again, how often would the half-inning end after 8 at-bats? How often would the the first at-bat result in a batter reaching first base? And how unusual is it to reach the state <code>0.111</code> from the state <code>0.110</code>?</p>
<p>In this lecture, we will build a <strong>Markov chain</strong> model, which is a simple probabilistic model of state transitions, to answer such questions. We briefly introduce the relevant mathematical details about Markov chains in <a href="#sec-markov-chain" class="quarto-xref">Section&nbsp;2</a> and work through some simple examples of Markov chains with two (<a href="#sec-two-state" class="quarto-xref">Section&nbsp;2.1</a>) and three (<a href="#sec-three-state" class="quarto-xref">Section&nbsp;3.2</a>) states. Then in <a href="#sec-half-inning" class="quarto-xref">Section&nbsp;4</a>, we build a Markov chain model to simulate an entire half-inning of baseball. Using this simulation, we study the distributions of the number of at-bats in a half-inning (<a href="#sec-halfinning-length" class="quarto-xref">Section&nbsp;4.3</a>) and the number of runs scored in a half-inning (<a href="#sec-runs-scored" class="quarto-xref">Section&nbsp;4.4</a>). Finally, in <a href="#sec-absorbing" class="quarto-xref">Section&nbsp;6</a>, we will lean on some mathematical properties of <em>absorbing Markov chains</em> to estimate how many more at-bats a team can expect to face given the current game state.</p>
<section id="sec-data-prep" class="level3">
<h3 class="anchored" data-anchor-id="sec-data-prep">Data Preparation</h3>
<p>The first at-bat in any half-inning of baseball has a deterministic starting state: <code>0.000</code>, with no outs and no runners on base. The starting state of the next at-bat is, in contrast, non-deterministic. Sometimes the first batter gets out out, in which the game transitions to the state <code>1.000</code>. But other times, the first batter gets base on with single (<code>0.1000</code>), double (<code>0.010</code>), or triple (<code>0.001</code>). More rarely, the batter scores a home run and the game state remains at <code>0.000</code>. Put another way, although the first game state visited in a half-inning is deterministic, the second game state visited is random.</p>
<p>From each possible second state, the game could move into multiple possible third states. Continuing this logic until the end of the half-inning, when the game state has <code>Outs = 3</code> and <code>BaseRunner</code> is undefined, the whole sequence of states visited is <em>stochastic</em>. So, if a team were to play the half-inning over and over again, the exact number of states visited (i.e., at-bats) and the precise sequence might vary from repetition to repetition. Markov chains offer a conceptually simple way to model the randomness of the sequence of game states visited in a half-inning.</p>
<p>To build a Markov chain model for baseball, we need to record the starting and ending state of every at-bat in the 2024 regular season. Recall that in our data table <code>atbat2024,</code> the variable <code>GameState</code> records the value of <span class="math inline">\(G_{t}\)</span> and was formed by concatenating the variables <code>Outs</code> and <code>BaseRunner</code>. In the code below, we create the variable <code>end_GameState</code> recording the ending state of each at-bat.</p>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-2"><pre class="sourceCode r code-annotation-code code-with-copy code-annotated"><code class="sourceCode r"><span id="annotated-cell-2-1"><a href="#annotated-cell-2-1" aria-hidden="true" tabindex="-1"></a>atbat2024 <span class="ot">&lt;-</span></span>
<span id="annotated-cell-2-2"><a href="#annotated-cell-2-2" aria-hidden="true" tabindex="-1"></a>  atbat2024 <span class="sc">|&gt;</span></span>
<span id="annotated-cell-2-3"><a href="#annotated-cell-2-3" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">mutate</span>(</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="1">1</button><span id="annotated-cell-2-4" class="code-annotation-target"><a href="#annotated-cell-2-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">end_BaseRunner =</span> <span class="fu">ifelse</span>(end_Outs <span class="sc">==</span> <span class="dv">3</span>, <span class="st">"000"</span>, end_BaseRunner),</span>
<span id="annotated-cell-2-5"><a href="#annotated-cell-2-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">end_GameState =</span> <span class="fu">paste</span>(end_Outs, end_BaseRunner, <span class="at">sep =</span> <span class="st">"."</span>))</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-2" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="4" data-code-annotation="1">For simplicity, we will set <code>end_BaseRunner = "000"</code> when <code>end_Outs == 3</code> (i.e., the inning is over).</span>
</dd>
</dl>
</div>
</div>
<p>It will later be convenient for us to keep a table listing the single game states as well as the corresponding number of outs and baserunner configurations.</p>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-3"><pre class="sourceCode r code-annotation-code code-with-copy code-annotated"><code class="sourceCode r"><span id="annotated-cell-3-1"><a href="#annotated-cell-3-1" aria-hidden="true" tabindex="-1"></a>outs <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>, <span class="dv">3</span>)</span>
<span id="annotated-cell-3-2"><a href="#annotated-cell-3-2" aria-hidden="true" tabindex="-1"></a>br <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"000"</span>, <span class="st">"100"</span>, <span class="st">"010"</span>, <span class="st">"001"</span>, <span class="st">"110"</span>, <span class="st">"101"</span>, <span class="st">"011"</span>, <span class="st">"111"</span>)</span>
<span id="annotated-cell-3-3"><a href="#annotated-cell-3-3" aria-hidden="true" tabindex="-1"></a>unik_states <span class="ot">&lt;-</span></span>
<span id="annotated-cell-3-4"><a href="#annotated-cell-3-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">expand.grid</span>(<span class="at">Outs =</span> outs, <span class="at">BaseRunner =</span> br) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-3-5"><a href="#annotated-cell-3-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as.data.frame</span>() <span class="sc">|&gt;</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="1">1</button><span id="annotated-cell-3-6" class="code-annotation-target"><a href="#annotated-cell-3-6" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">filter</span>(Outs <span class="sc">&lt;=</span> <span class="dv">2</span> <span class="sc">|</span> Outs <span class="sc">==</span> <span class="dv">3</span> <span class="sc">&amp;</span> BaseRunner <span class="sc">==</span> <span class="st">"000"</span>) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-3-7"><a href="#annotated-cell-3-7" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">arrange</span>(Outs) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-3-8"><a href="#annotated-cell-3-8" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">mutate</span>(</span>
<span id="annotated-cell-3-9"><a href="#annotated-cell-3-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">GameState =</span> <span class="fu">paste</span>(Outs, BaseRunner, <span class="at">sep =</span> <span class="st">"."</span>)) <span class="sc">|&gt;</span> </span>
<span id="annotated-cell-3-10"><a href="#annotated-cell-3-10" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>(Outs, BaseRunner, GameState)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-3" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="6" data-code-annotation="1">Remove impossible combinations like 3 outs and runners on 1st and 2nd base.</span>
</dd>
</dl>
</div>
</div>
</section>
</section>
<section id="sec-markov-chain" class="level2">
<h2 class="anchored" data-anchor-id="sec-markov-chain">Markov Chains</h2>
<p>Let us denote the game state at the start of at-bat <span class="math inline">\(t\)</span> of a half-inning as <span class="math inline">\(G_{t}.\)</span> There are 25 possible values for each <span class="math inline">\(G_{t}\)</span>: the 24 different combinations of <code>Outs</code> (0,1, and 2) and <code>BaseRunner</code> (“000”, “100”, “010”, “001”, “110”, “101”, “011”, and “111”) and the one state corresponding to the end of the half-inning. As discussed in <a href="#sec-overview" class="quarto-xref">Section&nbsp;1</a>, although <span class="math inline">\(G_{1}\)</span> is always equal to <code>0.000</code>, the remaining <span class="math inline">\(G_{t}\)</span>’s are random and the length of the sequence of states visited in the half-inning is also random.</p>
<p>Formally, this involves coming up with a <strong>joint</strong> probability distribution for the (possibly infinite) sequence <span class="math inline">\(G_{1}, G_{2}, \ldots.\)</span> That is, for every possible sequence of states visited, we would need to assign a probability. Once we do this, we could compute things like the probability of a half-inning lasting at least 5 at-bats by finding all sequences of length 5 or more and adding up the corresponding probabilities. Similarly, if we wanted to know the probability that the half-inning began by visiting the states <code>0.000</code>, <code>0.100</code>, <code>0.110</code>, and <code>0.111</code>, we would find all sequences with that starting sub-sequence and add up the corresponding probabilities.</p>
<p>Of course, calculating the probability for every possible sequence of every possible length is practically impossible. Luckily, it turns out that the probability distribution of a (possibly infinite) sequence of random variables <span class="math inline">\(\{G_{t}\}\)</span> is fully determined by the sequence of <em>conditional</em> distributions of the form <span class="math inline">\(G_{t} \vert G_{t-1}, \ldots, G_{1}.\)</span> In other words, it suffices to specify a probability distribution over the next state visited based on its past history.</p>
<p>A <strong>Markov chain</strong> is a probabilistic model in which the probability of the next state visited depends only on the current state and not all the previous states.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition: Markov Chain
</div>
</div>
<div class="callout-body-container callout-body">
<p>A sequence of random variables <span class="math inline">\(\left\{X_{t}\right\}_{n = 1}^{\infty}\)</span> is called a <strong>Markov chain</strong> if for all <span class="math inline">\(t \geq 1\)</span>, all sets <span class="math inline">\(A,\)</span> and trajectories <span class="math inline">\(x_{1}, \ldots, x_{t-1}\)</span> <span class="math display">\[
\mathbb{P}(X_{t} \in A \vert X_{t-1} = x_{t-1}, \ldots, X_{1} = x_{1}) = \mathbb{P}(X_{t} \in A \vert X_{t-1} = x_{t-1}).
\]</span></p>
</div>
</div>
<p>When the set of states is discrete (e.g., game states in baseball), Markov chains are fully characterized by a <strong>transition probability</strong> matrix. If there are <span class="math inline">\(S\)</span> different states, labelled without loss of generality as <span class="math inline">\(s = 1, \ldots, S,\)</span> then the <span class="math inline">\((s,s')\)</span> entry of the transition probability matrix is exactly <span class="math inline">\(\mathbb{P}(X_{t} = s' \vert X_{t-1} = s)\)</span>, the probability of transitioning from state <span class="math inline">\(s\)</span> to state <span class="math inline">\(s'.\)</span></p>
<section id="sec-two-state" class="level3">
<h3 class="anchored" data-anchor-id="sec-two-state">Example: A 2-state Markov Chain</h3>
<p>Suppose a system exists in one of two states <code>1</code> and `2. Further suppose that</p>
<ul>
<li>When the system is in state <code>1</code>, it can remain there with probability 0.6 and it can move to state <code>2</code> with probability 0.4.</li>
<li>When the system is in state <code>2</code>, it remains there with probability 0.5 and it moves to state <code>1</code> with probability 0.5.</li>
</ul>
<p>If we let <span class="math inline">\(X_{t}\)</span> be the state of the system at time <span class="math inline">\(t,\)</span> the transition matrix for the Markov chain <span class="math inline">\(\{X_{t}\}\)</span> is <span class="math display">\[
\begin{pmatrix}
0.6 &amp; 0.4 \\
0.5 &amp; 0.5
\end{pmatrix}
\]</span></p>
<p>The following code <em>simulate</em> 10 time steps from this Markov chain starting from the state <code>2</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-4"><pre class="sourceCode r code-annotation-code code-with-copy code-annotated"><code class="sourceCode r"><span id="annotated-cell-4-1"><a href="#annotated-cell-4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">479</span>) </span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="1">1</button><span id="annotated-cell-4-2" class="code-annotation-target"><a href="#annotated-cell-4-2" aria-hidden="true" tabindex="-1"></a>states <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>)</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="2">2</button><span id="annotated-cell-4-3" class="code-annotation-target"><a href="#annotated-cell-4-3" aria-hidden="true" tabindex="-1"></a>transition_matrix <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="fl">0.6</span>, <span class="fl">0.4</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>), <span class="at">nrow =</span> <span class="dv">2</span>, <span class="at">ncol =</span> <span class="dv">2</span>, <span class="at">byrow =</span> <span class="cn">TRUE</span>)</span>
<span id="annotated-cell-4-4"><a href="#annotated-cell-4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-5"><a href="#annotated-cell-4-5" aria-hidden="true" tabindex="-1"></a>n_steps <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="annotated-cell-4-6"><a href="#annotated-cell-4-6" aria-hidden="true" tabindex="-1"></a>init_state <span class="ot">&lt;-</span> <span class="dv">2</span></span>
<span id="annotated-cell-4-7"><a href="#annotated-cell-4-7" aria-hidden="true" tabindex="-1"></a>states_visited <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, <span class="at">times =</span> n_steps)</span>
<span id="annotated-cell-4-8"><a href="#annotated-cell-4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-9"><a href="#annotated-cell-4-9" aria-hidden="true" tabindex="-1"></a>states_visited[<span class="dv">1</span>] <span class="ot">&lt;-</span> init_state</span>
<span id="annotated-cell-4-10"><a href="#annotated-cell-4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-11"><a href="#annotated-cell-4-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(t <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>n_steps){</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="3">3</button><span id="annotated-cell-4-12" class="code-annotation-target"><a href="#annotated-cell-4-12" aria-hidden="true" tabindex="-1"></a>  prev_state <span class="ot">&lt;-</span> states_visited[t<span class="dv">-1</span>]</span>
<span id="annotated-cell-4-13"><a href="#annotated-cell-4-13" aria-hidden="true" tabindex="-1"></a>  probs <span class="ot">&lt;-</span> transition_matrix[prev_state,]</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="4">4</button><span id="annotated-cell-4-14" class="code-annotation-target"><a href="#annotated-cell-4-14" aria-hidden="true" tabindex="-1"></a>  next_state <span class="ot">&lt;-</span> <span class="fu">sample</span>(states, <span class="at">size =</span> <span class="dv">1</span>, <span class="at">prob =</span> probs)</span>
<span id="annotated-cell-4-15"><a href="#annotated-cell-4-15" aria-hidden="true" tabindex="-1"></a>  states_visited[t] <span class="ot">&lt;-</span> next_state</span>
<span id="annotated-cell-4-16"><a href="#annotated-cell-4-16" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="annotated-cell-4-17"><a href="#annotated-cell-4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-18"><a href="#annotated-cell-4-18" aria-hidden="true" tabindex="-1"></a>states_visited</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-4" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="2" data-code-annotation="1">Collection of all possible states</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="3,9" data-code-annotation="2">Setting <code>byrow = TRUE</code> forces R to build the matrix in row-major order instead of column-major (see <a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">this Wikipedia entry</a>)</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="12,13" data-code-annotation="3">Look up the current state and probabilities of moving to every other state from it. Note that this is a <strong>row</strong> of the transition matrix.</span>
</dd>
<dt data-target-cell="annotated-cell-4" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="14" data-code-annotation="4">Sample the next state based on the relevant row of the transition matrix</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 2 1 1 1 2 2 2 1 1 2</code></pre>
</div>
</div>
</section>
</section>
<section id="a-graphical-perspective" class="level2">
<h2 class="anchored" data-anchor-id="a-graphical-perspective">A Graphical Perspective</h2>
<p>We can visualize transition probability matrix <span class="math inline">\(\boldsymbol{\mathbf{P}}\)</span> with a <em>directed graph</em> whose vertices correspond to the distinct states and whose edges are weighted by the corresponding transition probabilities. In the graph, the edge from vertex <span class="math inline">\(s\)</span> to <span class="math inline">\(s'\)</span> is the assigned a weight of <span class="math inline">\(p_{s,s'},\)</span> which is the <span class="math inline">\((s,s')\)</span> entry of <span class="math inline">\(\boldsymbol{\mathbf{P}}\)</span> and equals the probability of moving to state <span class="math inline">\(s'\)</span> from state <span class="math inline">\(s.\)</span> <a href="#fig-twostate-graph" class="quarto-xref">Figure&nbsp;1</a> illustrates the graph corresponding to the simple two-state Markov chain from before.</p>
<div id="fig-twostate-graph" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-twostate-graph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="figures/two-state-graph.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Figure&nbsp;1: Graphical representation of the transition probabilities in a two-state Markov chain with one absorbing state"><img src="figures/two-state-graph.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:50.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-twostate-graph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Graphical representation of the transition probabilities in a two-state Markov chain with one absorbing state
</figcaption>
</figure>
</div>
<p>We can interpret a Markov chain with transition matrix <span class="math inline">\(\boldsymbol{\mathbf{P}}\)</span> as a <em>random walk</em> along this graph. Whenever the walk is at vertex <span class="math inline">\(s\)</span>, it picks one of the outgoing edges from <span class="math inline">\(s\)</span> to follow at a random. The probability that the walk follows the edge from <span class="math inline">\(s\)</span> to <span class="math inline">\(s'\)</span></p>
<section id="absorbing-states" class="level3">
<h3 class="anchored" data-anchor-id="absorbing-states">Absorbing States</h3>
<p>Suppose that <span class="math inline">\(\{X_{t}\}\)</span> is a Markov chain defined over the states <span class="math inline">\(\{1, 2, \ldots, S\}\)</span> and let <span class="math inline">\(\boldsymbol{\mathbf{P}}\)</span> be its transition matrix.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition: Absorbing State
</div>
</div>
<div class="callout-body-container callout-body">
<p>A state <span class="math inline">\(s\)</span> is called an <strong>absorbing state</strong> if for all <span class="math inline">\(s' \neq s,\)</span> <span class="math inline">\(\mathbb{P}(X_{t} = s' \vert X_{t-1} = s) = 0\)</span> and <span class="math inline">\(\mathbb{P}(X_{t} = s \vert X_{t-1} = s) = 1.\)</span></p>
</div>
</div>
<p>That is, an absorbing state is one from which there are no out-going transitions: once the chain reaches an absorbing state, it cannot leave. In our baseball analysis, the state <code>3.000</code> corresponding to the end of the half-inning is an absorbing.</p>
<p>As an illustration, here is the transition matrix for 3-state Markov chain model with one absorbing state (<code>3</code>) <span class="math display">\[
\begin{pmatrix}
0.5 &amp; 0.25 &amp; 0.25 \\
0.25 &amp; 0.25 &amp; 0.5 \\
0 &amp; 0 &amp; 1
\end{pmatrix}
\]</span> If the chain is currently in state <code>1</code>, it (i) remains in state <code>1</code> 50% of the time and (ii) moves to states <code>2</code> 25% of the time; and (iii) moves to state <code>3</code> 25% of the time. If the chain is currently in state <code>2</code>, it (i) moves to state <code>1</code> 25% of the time; (ii) remains in state <code>2</code> 25% of the time; and moves to state <code>3</code> 50% of the time.</p>
<p><a href="#fig-threestate-graph" class="quarto-xref">Figure&nbsp;2</a> is a graphical illustration of this transition matrix. Notice that the absorbing state <code>3</code> only has one outgoing edge that (i) leads back to itself and (ii) has an edge weight of one.</p>
<div id="fig-threestate-graph" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-threestate-graph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="figures/three-state-graph.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Figure&nbsp;2: Graphical representation of the transition probabilities in a three-state Markov chain with one absorbing state"><img src="figures/three-state-graph.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:50.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-threestate-graph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Graphical representation of the transition probabilities in a three-state Markov chain with one absorbing state
</figcaption>
</figure>
</div>
<p>The following code simulates 10 steps of the Markov chain beginning in state <code>1</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-5"><pre class="sourceCode r code-annotation-code code-with-copy"><code class="sourceCode r"><span id="annotated-cell-5-1"><a href="#annotated-cell-5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">129</span>) </span>
<span id="annotated-cell-5-2"><a href="#annotated-cell-5-2" aria-hidden="true" tabindex="-1"></a>states <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>, <span class="dv">3</span>)</span>
<span id="annotated-cell-5-3"><a href="#annotated-cell-5-3" aria-hidden="true" tabindex="-1"></a>transition_matrix <span class="ot">&lt;-</span> </span>
<span id="annotated-cell-5-4"><a href="#annotated-cell-5-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="fl">0.25</span>, <span class="fl">0.5</span>, <span class="fl">0.25</span>,</span>
<span id="annotated-cell-5-5"><a href="#annotated-cell-5-5" aria-hidden="true" tabindex="-1"></a>           <span class="fl">0.25</span>, <span class="fl">0.25</span>, <span class="fl">0.5</span>,</span>
<span id="annotated-cell-5-6"><a href="#annotated-cell-5-6" aria-hidden="true" tabindex="-1"></a>           <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>), <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">ncol =</span> <span class="dv">3</span>, <span class="at">byrow =</span> <span class="cn">TRUE</span>)</span>
<span id="annotated-cell-5-7"><a href="#annotated-cell-5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-8"><a href="#annotated-cell-5-8" aria-hidden="true" tabindex="-1"></a>n_steps <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="annotated-cell-5-9"><a href="#annotated-cell-5-9" aria-hidden="true" tabindex="-1"></a>init_state <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="annotated-cell-5-10"><a href="#annotated-cell-5-10" aria-hidden="true" tabindex="-1"></a>states_visited <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, <span class="at">times =</span> n_steps)</span>
<span id="annotated-cell-5-11"><a href="#annotated-cell-5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-12"><a href="#annotated-cell-5-12" aria-hidden="true" tabindex="-1"></a>states_visited[<span class="dv">1</span>] <span class="ot">&lt;-</span> init_state</span>
<span id="annotated-cell-5-13"><a href="#annotated-cell-5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-14"><a href="#annotated-cell-5-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(t <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>n_steps){</span>
<span id="annotated-cell-5-15"><a href="#annotated-cell-5-15" aria-hidden="true" tabindex="-1"></a>  prev_state <span class="ot">&lt;-</span> states_visited[t<span class="dv">-1</span>]</span>
<span id="annotated-cell-5-16"><a href="#annotated-cell-5-16" aria-hidden="true" tabindex="-1"></a>  probs <span class="ot">&lt;-</span> transition_matrix[prev_state,]</span>
<span id="annotated-cell-5-17"><a href="#annotated-cell-5-17" aria-hidden="true" tabindex="-1"></a>  next_state <span class="ot">&lt;-</span> <span class="fu">sample</span>(states, <span class="at">size =</span> <span class="dv">1</span>, <span class="at">prob =</span> probs)</span>
<span id="annotated-cell-5-18"><a href="#annotated-cell-5-18" aria-hidden="true" tabindex="-1"></a>  states_visited[t] <span class="ot">&lt;-</span> next_state</span>
<span id="annotated-cell-5-19"><a href="#annotated-cell-5-19" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="annotated-cell-5-20"><a href="#annotated-cell-5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-5-21"><a href="#annotated-cell-5-21" aria-hidden="true" tabindex="-1"></a>states_visited</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 1 2 3 3 3 3 3 3 3 3</code></pre>
</div>
</div>
<p>In this particular simulation, the chain begins in state <code>1</code>, moves to state <code>2,</code> and then moves to the absorbing state <code>3</code>. The following code block repeats the simulation 10 times, each time starting at state <code>1</code> and simulating 10 steps of the Markov chain. Sometimes, the chain immediately moves from <code>1</code> to the absorbing state <code>3</code>. But other times, the chain hops between states <code>1</code> and <code>2</code> before eventually being absorbed.</p>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-6"><pre class="sourceCode r code-annotation-code code-with-copy code-annotated"><code class="sourceCode r"><span id="annotated-cell-6-1"><a href="#annotated-cell-6-1" aria-hidden="true" tabindex="-1"></a>n_sims <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="annotated-cell-6-2"><a href="#annotated-cell-6-2" aria-hidden="true" tabindex="-1"></a>n_steps <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="annotated-cell-6-3"><a href="#annotated-cell-6-3" aria-hidden="true" tabindex="-1"></a>init_state <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="annotated-cell-6-4"><a href="#annotated-cell-6-4" aria-hidden="true" tabindex="-1"></a>states_visited <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, <span class="at">times =</span> n_steps)</span>
<span id="annotated-cell-6-5"><a href="#annotated-cell-6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-6-6"><a href="#annotated-cell-6-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(r <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n_sims){</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-6" data-target-annotation="1">1</button><span id="annotated-cell-6-7" class="code-annotation-target"><a href="#annotated-cell-6-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(<span class="dv">479</span><span class="sc">+</span>r)</span>
<span id="annotated-cell-6-8"><a href="#annotated-cell-6-8" aria-hidden="true" tabindex="-1"></a>  states_visited <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, <span class="at">times =</span> n_steps)</span>
<span id="annotated-cell-6-9"><a href="#annotated-cell-6-9" aria-hidden="true" tabindex="-1"></a>  states_visited[<span class="dv">1</span>] <span class="ot">&lt;-</span> init_state</span>
<span id="annotated-cell-6-10"><a href="#annotated-cell-6-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(t <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>n_steps){</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-6" data-target-annotation="2">2</button><span id="annotated-cell-6-11" class="code-annotation-target"><a href="#annotated-cell-6-11" aria-hidden="true" tabindex="-1"></a>    states_visited[t] <span class="ot">&lt;-</span></span>
<span id="annotated-cell-6-12"><a href="#annotated-cell-6-12" aria-hidden="true" tabindex="-1"></a>      <span class="fu">sample</span>(states, <span class="at">size =</span> <span class="dv">1</span>,</span>
<span id="annotated-cell-6-13"><a href="#annotated-cell-6-13" aria-hidden="true" tabindex="-1"></a>              <span class="at">prob =</span> transition_matrix[states_visited[t<span class="dv">-1</span>],])</span>
<span id="annotated-cell-6-14"><a href="#annotated-cell-6-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-6" data-target-annotation="3">3</button><span id="annotated-cell-6-15" class="code-annotation-target"><a href="#annotated-cell-6-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cat</span>(<span class="st">"Simulation "</span>, r, <span class="st">":"</span>, states_visited, <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="annotated-cell-6-16"><a href="#annotated-cell-6-16" aria-hidden="true" tabindex="-1"></a>}</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-6" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-6" data-code-lines="7" data-code-annotation="1">Setting seed ensures reproducibility. Allowing the seed to change systematically with replication number ensures we don’t get the exact same results across replications.</span>
</dd>
<dt data-target-cell="annotated-cell-6" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-6" data-code-lines="11,12,13" data-code-annotation="2">There is actually no need to introduce the intermediate variables <code>prev_state</code> and <code>next_state</code></span>
</dd>
<dt data-target-cell="annotated-cell-6" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-6" data-code-lines="15" data-code-annotation="3">Prints out the sequence of states visited</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Simulation  1 : 1 3 3 3 3 3 3 3 3 3 
Simulation  2 : 1 2 3 3 3 3 3 3 3 3 
Simulation  3 : 1 2 2 3 3 3 3 3 3 3 
Simulation  4 : 1 2 3 3 3 3 3 3 3 3 
Simulation  5 : 1 2 2 1 1 2 3 3 3 3 
Simulation  6 : 1 2 3 3 3 3 3 3 3 3 
Simulation  7 : 1 2 3 3 3 3 3 3 3 3 
Simulation  8 : 1 3 3 3 3 3 3 3 3 3 
Simulation  9 : 1 2 1 1 1 1 2 3 3 3 
Simulation  10 : 1 1 3 3 3 3 3 3 3 3 </code></pre>
</div>
</div>
</section>
<section id="sec-three-state" class="level3">
<h3 class="anchored" data-anchor-id="sec-three-state">Example: Simulating Time to Absorption</h3>
<p>In our 3-state example, let <span class="math inline">\(T^{A}_{1}\)</span> be the number of steps the chain takes until it hits state <code>3</code> starting from state <code>1</code>: <span class="math display">\[
T^{A}_{1} = \min\left\{t \geq 1 : X_{t} = 3\right\}.
\]</span> We can use simulation to study the distribution of <span class="math inline">\(T^{A}_{1}\)</span> and to estimate quantities like <span class="math inline">\(\mathbb{P}(T^{A}_{1} &gt; 3)\)</span> or <span class="math inline">\(\mathbb{P}(T^{A}_{1} = 5).\)</span></p>
<p>The following code block uses a <code>while()</code> loop to simulate the Markov chain for several iterations until either (i) the absorbing state <code>3</code> is reached or (ii) some maximum number of iterations is hit<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Unlike our earlier simulation code, we will not save the full trajectory of states visited. Instead, we will only keep track of the number of iterations needed until the chain reaches state <code>3</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-7"><pre class="sourceCode r code-annotation-code code-with-copy code-annotated"><code class="sourceCode r"><button class="code-annotation-anchor" data-target-cell="annotated-cell-7" data-target-annotation="1">1</button><span id="annotated-cell-7-1" class="code-annotation-target"><a href="#annotated-cell-7-1" aria-hidden="true" tabindex="-1"></a>n_sims <span class="ot">&lt;-</span> <span class="fl">1e4</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-7" data-target-annotation="2">2</button><span id="annotated-cell-7-2" class="code-annotation-target"><a href="#annotated-cell-7-2" aria-hidden="true" tabindex="-1"></a>max_iterations <span class="ot">&lt;-</span> <span class="fl">1e3</span></span>
<span id="annotated-cell-7-3"><a href="#annotated-cell-7-3" aria-hidden="true" tabindex="-1"></a>states <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>)</span>
<span id="annotated-cell-7-4"><a href="#annotated-cell-7-4" aria-hidden="true" tabindex="-1"></a>transition_matrix <span class="ot">&lt;-</span> </span>
<span id="annotated-cell-7-5"><a href="#annotated-cell-7-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="fl">0.25</span>, <span class="fl">0.5</span>, <span class="fl">0.25</span>,</span>
<span id="annotated-cell-7-6"><a href="#annotated-cell-7-6" aria-hidden="true" tabindex="-1"></a>           <span class="fl">0.25</span>, <span class="fl">0.25</span>, <span class="fl">0.5</span>,</span>
<span id="annotated-cell-7-7"><a href="#annotated-cell-7-7" aria-hidden="true" tabindex="-1"></a>           <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>), <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">ncol =</span> <span class="dv">3</span>, <span class="at">byrow =</span> <span class="cn">TRUE</span>)</span>
<span id="annotated-cell-7-8"><a href="#annotated-cell-7-8" aria-hidden="true" tabindex="-1"></a>absorption_time <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, <span class="at">times =</span> n_sims)</span>
<span id="annotated-cell-7-9"><a href="#annotated-cell-7-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(r <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n_sims){</span>
<span id="annotated-cell-7-10"><a href="#annotated-cell-7-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(<span class="dv">479</span><span class="sc">+</span>r)</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-7" data-target-annotation="3">3</button><span id="annotated-cell-7-11" class="code-annotation-target"><a href="#annotated-cell-7-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(r <span class="sc">%%</span> <span class="dv">1000</span> <span class="sc">==</span> <span class="dv">0</span>) <span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"Simulation"</span>, r, <span class="st">"at"</span>, <span class="fu">Sys.time</span>()))</span>
<span id="annotated-cell-7-12"><a href="#annotated-cell-7-12" aria-hidden="true" tabindex="-1"></a>  </span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-7" data-target-annotation="4">4</button><span id="annotated-cell-7-13" class="code-annotation-target"><a href="#annotated-cell-7-13" aria-hidden="true" tabindex="-1"></a>  iteration_counter <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="annotated-cell-7-14"><a href="#annotated-cell-7-14" aria-hidden="true" tabindex="-1"></a>  current_state <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-7" data-target-annotation="5">5</button><span id="annotated-cell-7-15" class="code-annotation-target"><a href="#annotated-cell-7-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span>(current_state <span class="sc">!=</span> <span class="dv">3</span> <span class="sc">&amp;</span> iteration_counter <span class="sc">&lt;</span> max_iterations){</span>
<span id="annotated-cell-7-16"><a href="#annotated-cell-7-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="annotated-cell-7-17"><a href="#annotated-cell-7-17" aria-hidden="true" tabindex="-1"></a>    current_state <span class="ot">&lt;-</span></span>
<span id="annotated-cell-7-18"><a href="#annotated-cell-7-18" aria-hidden="true" tabindex="-1"></a>      <span class="fu">sample</span>(states, <span class="at">size =</span> <span class="dv">1</span>,</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-7" data-target-annotation="6">6</button><span id="annotated-cell-7-19" class="code-annotation-target"><a href="#annotated-cell-7-19" aria-hidden="true" tabindex="-1"></a>             <span class="at">prob =</span> transition_matrix[current_state,])</span>
<span id="annotated-cell-7-20"><a href="#annotated-cell-7-20" aria-hidden="true" tabindex="-1"></a>    </span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-7" data-target-annotation="7">7</button><span id="annotated-cell-7-21" class="code-annotation-target"><a href="#annotated-cell-7-21" aria-hidden="true" tabindex="-1"></a>    iteration_counter <span class="ot">&lt;-</span> iteration_counter <span class="sc">+</span> <span class="dv">1</span></span>
<span id="annotated-cell-7-22"><a href="#annotated-cell-7-22" aria-hidden="true" tabindex="-1"></a>  }</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-7" data-target-annotation="8">8</button><span id="annotated-cell-7-23" class="code-annotation-target"><a href="#annotated-cell-7-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(iteration_counter <span class="sc">&lt;</span> max_iterations <span class="sc">&amp;</span> current_state <span class="sc">==</span> <span class="dv">3</span>){</span>
<span id="annotated-cell-7-24"><a href="#annotated-cell-7-24" aria-hidden="true" tabindex="-1"></a>    absorption_time[r] <span class="ot">&lt;-</span> iteration_counter</span>
<span id="annotated-cell-7-25"><a href="#annotated-cell-7-25" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="annotated-cell-7-26"><a href="#annotated-cell-7-26" aria-hidden="true" tabindex="-1"></a>}</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-7" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-7" data-code-lines="1" data-code-annotation="1">Number of simulation runs</span>
</dd>
<dt data-target-cell="annotated-cell-7" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-7" data-code-lines="2" data-code-annotation="2">Maximum number of Markov chain iterations/steps per simulation</span>
</dd>
<dt data-target-cell="annotated-cell-7" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-7" data-code-lines="11" data-code-annotation="3">When running large simulations, it’s helpful to print out your progress after a fixed number of iterations (in this case 100). <code>Sys.time()</code> prints the system time.</span>
</dd>
<dt data-target-cell="annotated-cell-7" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-7" data-code-lines="13,14" data-code-annotation="4">In each simulation (i.e., iteration of the outer <code>for</code> loop), we need to re-set the counter tracking the number of steps for which we simulate the Markov chain (i.e., iteration counter in the inner <code>while()</code> loop) and re-set the <code>current_state</code> variable to the starting state (in this case, <code>1</code>).</span>
</dd>
<dt data-target-cell="annotated-cell-7" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-7" data-code-lines="15" data-code-annotation="5">Before starting each iteration, the <code>while()</code> loop checks that the chain isn’t in state <code>3</code> and we haven’t yet hit the maximum number of iterations.</span>
</dd>
<dt data-target-cell="annotated-cell-7" data-target-annotation="6">6</dt>
<dd>
<span data-code-cell="annotated-cell-7" data-code-lines="19" data-code-annotation="6">R evaluates the whole expression on the right-hand side of the <code>&lt;-</code> before assigning it to whatever is on the left-hand side. So, there is no danger here of simultaneously accessing and over-writing the variable <code>current_state</code>, which appears on both sides.</span>
</dd>
<dt data-target-cell="annotated-cell-7" data-target-annotation="7">7</dt>
<dd>
<span data-code-cell="annotated-cell-7" data-code-lines="21" data-code-annotation="7">In a <code>while()</code> loop, it’s imperative to increment the iterator!</span>
</dd>
<dt data-target-cell="annotated-cell-7" data-target-annotation="8">8</dt>
<dd>
<span data-code-cell="annotated-cell-7" data-code-lines="23,24,25" data-code-annotation="8">The condition fails only when the chain has not reached the absorbing state within the maximum number of allowed iterations (<code>max_iterations</code>).</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Simulation 1000 at 2025-10-19 10:10:37.954593"
[1] "Simulation 2000 at 2025-10-19 10:10:37.966918"
[1] "Simulation 3000 at 2025-10-19 10:10:37.978179"
[1] "Simulation 4000 at 2025-10-19 10:10:37.987583"
[1] "Simulation 5000 at 2025-10-19 10:10:37.997012"
[1] "Simulation 6000 at 2025-10-19 10:10:38.007813"
[1] "Simulation 7000 at 2025-10-19 10:10:38.017058"
[1] "Simulation 8000 at 2025-10-19 10:10:38.028058"
[1] "Simulation 9000 at 2025-10-19 10:10:38.037713"
[1] "Simulation 10000 at 2025-10-19 10:10:38.048375"</code></pre>
</div>
</div>
<p>Because there are only 3 states and the probabilities of transitioning to state <code>3</code> from states <code>1</code> and <code>2</code> are relatively high, simulating the Markov chain until it hits state <code>3</code> takes very little time. Tabulating the different values in <code>absorption_time</code>, we see that the chain</p>
<ol type="1">
<li>Immediately transitioned from state <code>1</code> to state <code>3</code> in one step (so that <span class="math inline">\(T^{A}_{1} = 2\)</span>) in 2440 of the 10,000 simulations</li>
<li>Reached state <code>3</code> in exactly two steps (so <span class="math inline">\(T^{A}_{1} = 2\)</span>) in about 3200 of the 10,000 simulations</li>
<li>Reached state <code>3</code> after 20 or more steps in just 2 of the 10,000 simulation</li>
<li>Always reached state <code>3</code> within the maximum number of iterations (as indicated by the fact that there are no <code>NA</code> values in <code>absorption_time</code>)</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(absorption_time, <span class="at">useNA =</span> <span class="st">'always'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>absorption_time
   2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17 
2511 3209 1701  995  586  395  226  159   83   52   32   20   12    8    6    1 
  18   19   24 &lt;NA&gt; 
   2    1    1    0 </code></pre>
</div>
</div>
</section>
</section>
<section id="sec-half-inning" class="level2">
<h2 class="anchored" data-anchor-id="sec-half-inning">A Markov Chain Model for Half-Innings</h2>
<p>Our goal is to build a Markov chain model for a half-inning of baseball. The fundamental feature of Markov chains is that the state the chain visits next depends only on its current state and not on any of the previously visited states. This is known as the <em>Markov property</em>. Put more somewhat more poetically, the Markov property means that the future depends only on the present and not on the past. In a baseball context, this would mean that what happens after the game reaches any particular state does not depend on what ultimately lead to the current state. So, for instance, when predicting what might happen after the game reaches the state <code>2.110</code>, with runners on 1st and 2nd base and two outs, it doesn’t matter whether the state was reached from <code>1.110</code> or <code>2.100</code>.<br>
It is important to note, we are <strong>assuming</strong> that the Markov property holds.</p>
<p>Ultimately, we must estimate the transition probabilities between every pair of the 24 non-absorbing states and the absorbing state corresponding to the end of the half-inning. Because the 9th inning (and any extra innings) can end before a team has amassed three outs<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, we exclude all data from the 9th inning and beyond.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>atbat2024 <span class="ot">&lt;-</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  atbat2024 <span class="sc">|&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">filter</span>(inning <span class="sc">&lt;</span> <span class="dv">9</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="sec-estimate-transitions" class="level3">
<h3 class="anchored" data-anchor-id="sec-estimate-transitions">Estimating Transition Probabilities</h3>
<p>A natural estimate of the the probability for transitioning from state <span class="math inline">\(s\)</span> to the state $s’ $ is divide the number of at-bats that start in state <span class="math inline">\(s\)</span> and end in state <span class="math inline">\(s'\)</span> by the number of at-bats that start in state <span class="math inline">\(s.\)</span></p>
<p>We first build a table that counts the number of at-bats starting in every state</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>start_counts <span class="ot">&lt;-</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  atbat2024 <span class="sc">|&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">group_by</span>(GameState) <span class="sc">|&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">summarise</span>(<span class="at">n_start =</span> dplyr<span class="sc">::</span><span class="fu">n</span>(), <span class="at">.groups =</span> <span class="st">"drop"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, by grouping by each of <code>GameState</code> and <code>end_GameState</code>, we can count the number of times an at-bat started in some state <span class="math inline">\(s\)</span> and ended in state <span class="math inline">\(s'.\)</span></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>end_counts <span class="ot">&lt;-</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  atbat2024 <span class="sc">|&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">group_by</span>(GameState, end_GameState) <span class="sc">|&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">summarise</span>(<span class="at">n_start_end =</span> dplyr<span class="sc">::</span><span class="fu">n</span>(), <span class="at">.groups =</span> <span class="st">"drop"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To compute our transition probability estimates, we start by enumerating all possible combinations of starting and ending state. Then, we will append columns containing the starting state counts <code>n_start</code> and the counts of each pair of state transitions (i.e., <code>n_start_end</code>). For certain pairs of transitions that do not appear in our data (e.g., <code>0.000</code> to <code>3.000</code>), we will manually set <code>n_start_end = 0</code>. Finally, we will divide <code>n_start_end</code> by <code>n_start</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-12"><pre class="sourceCode r code-annotation-code code-with-copy code-annotated"><code class="sourceCode r"><span id="annotated-cell-12-1"><a href="#annotated-cell-12-1" aria-hidden="true" tabindex="-1"></a>transitions <span class="ot">&lt;-</span></span>
<span id="annotated-cell-12-2"><a href="#annotated-cell-12-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">expand.grid</span>(<span class="at">GameState =</span> unik_states<span class="sc">$</span>GameState,</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-12" data-target-annotation="1">1</button><span id="annotated-cell-12-3" class="code-annotation-target"><a href="#annotated-cell-12-3" aria-hidden="true" tabindex="-1"></a>              <span class="at">end_GameState =</span> unik_states<span class="sc">$</span>GameState) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-12-4"><a href="#annotated-cell-12-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as.data.frame</span>() <span class="sc">|&gt;</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-12" data-target-annotation="2">2</button><span id="annotated-cell-12-5" class="code-annotation-target"><a href="#annotated-cell-12-5" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">left_join</span>(<span class="at">y =</span> start_counts, <span class="at">by =</span> <span class="st">"GameState"</span>) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-12-6"><a href="#annotated-cell-12-6" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">left_join</span>(<span class="at">y =</span> end_counts, <span class="at">by =</span> <span class="fu">c</span>(<span class="st">"GameState"</span>, <span class="st">"end_GameState"</span>)) <span class="sc">|&gt;</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-12" data-target-annotation="3">3</button><span id="annotated-cell-12-7" class="code-annotation-target"><a href="#annotated-cell-12-7" aria-hidden="true" tabindex="-1"></a>  tidyr<span class="sc">::</span><span class="fu">replace_na</span>(<span class="at">replace =</span> <span class="fu">list</span>(<span class="at">n_start_end=</span><span class="dv">0</span>)) <span class="sc">|&gt;</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-12" data-target-annotation="4">4</button><span id="annotated-cell-12-8" class="code-annotation-target"><a href="#annotated-cell-12-8" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">mutate</span>(<span class="at">prob =</span> n_start_end<span class="sc">/</span>n_start) <span class="sc">|&gt;</span></span>
<span id="annotated-cell-12-9"><a href="#annotated-cell-12-9" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">mutate</span>(</span>
<span id="annotated-cell-12-10"><a href="#annotated-cell-12-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">prob =</span> dplyr<span class="sc">::</span><span class="fu">case_when</span>(</span>
<span id="annotated-cell-12-11"><a href="#annotated-cell-12-11" aria-hidden="true" tabindex="-1"></a>      GameState <span class="sc">==</span> <span class="st">"3.000"</span> <span class="sc">&amp;</span> end_GameState <span class="sc">!=</span> <span class="st">"3.000"</span> <span class="sc">~</span> <span class="dv">0</span>,</span>
<span id="annotated-cell-12-12"><a href="#annotated-cell-12-12" aria-hidden="true" tabindex="-1"></a>      GameState <span class="sc">==</span> <span class="st">"3.000"</span> <span class="sc">&amp;</span> end_GameState <span class="sc">==</span> <span class="st">"3.000"</span> <span class="sc">~</span> <span class="dv">1</span>,</span>
<span id="annotated-cell-12-13"><a href="#annotated-cell-12-13" aria-hidden="true" tabindex="-1"></a>      <span class="at">.default =</span> prob))</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-12" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-12" data-code-lines="3" data-code-annotation="1">Enumerate all 625 possible combinations of starting and ending states of an at-bat</span>
</dd>
<dt data-target-cell="annotated-cell-12" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-12" data-code-lines="5,6" data-code-annotation="2">Append columns with the number of at-bats (i) starting in each state and (ii) starting &amp; ending in each combination of states</span>
</dd>
<dt data-target-cell="annotated-cell-12" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-12" data-code-lines="7" data-code-annotation="3">Manually set <code>n_start_end = 0</code> for transitions that are not observed in the data</span>
</dd>
<dt data-target-cell="annotated-cell-12" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-12" data-code-lines="8" data-code-annotation="4">Estimate the transition probability</span>
</dd>
</dl>
</div>
</div>
<p>It is perhaps unsurprising to see that some of the highest transition probabilities are from 2-out states (e.g., <code>2.000</code> or <code>2.100</code>) to the absorbing 3-out state.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>transitions <span class="sc">|&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">arrange</span>(dplyr<span class="sc">::</span><span class="fu">desc</span>(prob)) <span class="sc">|&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">slice_head</span>(<span class="at">n =</span> <span class="dv">10</span>) <span class="sc">|&gt;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">mutate</span>(<span class="at">prob =</span> <span class="fu">round</span>(prob, <span class="at">digits =</span> <span class="dv">3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   GameState end_GameState n_start n_start_end  prob
1      2.110         3.000    4797        3350 0.698
2      2.000         3.000   23149       16118 0.696
3      2.001         3.000    1975        1369 0.693
4      1.000         2.000   29062       20103 0.692
5      2.101         3.000    2431        1673 0.688
6      0.000         1.000   39733       27316 0.687
7      2.100         3.000   11962        8203 0.686
8      2.111         3.000    1631        1112 0.682
9      2.010         3.000    4840        3258 0.673
10     2.011         3.000    1164         776 0.667</code></pre>
</div>
</div>
<p>To form a transition matrix, we will first “widen” the table <code>transitions</code> using the function <a href="https://tidyr.tidyverse.org/reference/pivot_wider.html"><code>tiyr::pivot_wider()</code></a>. We see that each row of the resulting, temporary table, which we call <code>tmp</code>, corresponds to a starting game state value and there are columns for each of the ending game states.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>tmp <span class="ot">&lt;-</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  transitions <span class="sc">|&gt;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>(GameState, end_GameState, prob) <span class="sc">|&gt;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  tidyr<span class="sc">::</span><span class="fu">pivot_wider</span>(<span class="at">names_from =</span> <span class="st">"end_GameState"</span>,</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>                      <span class="at">values_from =</span> <span class="st">"prob"</span>)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>tmp <span class="sc">|&gt;</span> </span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>(GameState, <span class="st">`</span><span class="at">0.000</span><span class="st">`</span>, <span class="st">`</span><span class="at">0.100</span><span class="st">`</span>, <span class="st">`</span><span class="at">1.000</span><span class="st">`</span>, <span class="st">`</span><span class="at">2.000</span><span class="st">`</span>) <span class="sc">|&gt;</span> </span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">slice_head</span>(<span class="at">n =</span> <span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 10 × 5
   GameState `0.000`  `0.100`  `1.000` `2.000`
   &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;
 1 0.000      0.0316 0.231    0.687    0      
 2 0.100      0.0312 0.00277  0.00170  0.120  
 3 0.010      0.0207 0.0573   0.00282  0.00987
 4 0.001      0.0380 0.179    0.213    0.0114 
 5 0.110      0.0304 0.000440 0.000440 0.00132
 6 0.101      0.0358 0.00133  0.00265  0.0491 
 7 0.011      0.0370 0.0545   0.00654  0      
 8 0.111      0.0417 0        0.00348  0      
 9 1.000      0      0        0.0295   0.692  
10 1.100      0      0        0.0339   0.00300</code></pre>
</div>
</div>
<p>Looking at these selected entries, we find that the estimated transition probability from <code>0.000</code> to <code>2.000</code> is zero. This makes some intuitive sense as the batting team cannot, with no outs and no runners on base, lost two outs in a single at-bat. We also see that the transition probabilities from 1 out states (e.g., <code>1.000</code> and <code>1.1000</code>) to the no-out states (e.g., <code>0.000</code>, <code>0.110</code>, etc.) are also estimated to be zero. Transitions like <code>0.100</code> to <code>0.000</code> correspond to situations in which the at-bat begins with a runner on first base and ends with the batter hitting a homerun and driving in the runner.</p>
<p>We can now turn this table into a matrix row and column names are the possible starting and ending game states, we will drop the column <code>GameState</code> from <code>tmp</code>, convert it into a matrix, and then assign the rownames.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>state_names <span class="ot">&lt;-</span> tmp <span class="sc">|&gt;</span> dplyr<span class="sc">::</span><span class="fu">pull</span>(GameState)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>transition_matrix <span class="ot">&lt;-</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  tmp <span class="sc">|&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="sc">-</span>GameState) <span class="sc">|&gt;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as.matrix</span>()</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(transition_matrix) <span class="ot">&lt;-</span> state_names</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(transition_matrix[<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>], <span class="at">digits =</span> <span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      0.000 0.100 0.010 0.001 0.110
0.000 0.032 0.231 0.045 0.005 0.000
0.100 0.031 0.003 0.014 0.004 0.198
0.010 0.021 0.057 0.048 0.003 0.093
0.001 0.038 0.179 0.046 0.008 0.000
0.110 0.030 0.000 0.011 0.005 0.039</code></pre>
</div>
</div>
<p><a href="#fig-baseball-graph" class="quarto-xref">Figure&nbsp;3</a> shows a graphical representation of the transition matrix between the game states in baseball. In the figure, the color and thickness of each edge between different states is proportional to corresponding edge transition probabilities, with colors range from blue (0%) to red (100%). So that they are more readily apparent, we have highlighted the self-edges.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output cell-output-stderr">
<pre><code>
Attaching package: 'igraph'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following objects are masked from 'package:stats':

    decompose, spectrum</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following object is masked from 'package:base':

    union</code></pre>
</div>
<div class="cell-output-display">
<div id="fig-baseball-graph" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-baseball-graph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="lecture14_files/figure-html/fig-baseball-graph-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Figure&nbsp;3: Graphical representation of transitions between game states in baseball"><img src="lecture14_files/figure-html/fig-baseball-graph-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="768"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-baseball-graph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Graphical representation of transitions between game states in baseball
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="sec-simulation" class="level3">
<h3 class="anchored" data-anchor-id="sec-simulation">Simulating a Half-Inning</h3>
<p>Now that we have estimated the transition probabilities between all pairs of game states, we are in a position to <em>simulate</em> a single half-inning of baseball. In the following code, we set the initial state to <code>0.000</code>, since an innings begins with no outs and no runners on base. Then, we use a <code>while()</code> loop to simulate a Markov chain that randomly walks between the states (according to the transition matrix) until it hits the absorbing state <code>3.000</code>. We set the maximum iterations to be 30, which is an admittedly gross over-estimate on the number of at-bats that can take place in a single half-inning.</p>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-16"><pre class="sourceCode r code-annotation-code code-with-copy code-annotated"><code class="sourceCode r"><span id="annotated-cell-16-1"><a href="#annotated-cell-16-1" aria-hidden="true" tabindex="-1"></a>max_iterations <span class="ot">&lt;-</span> <span class="dv">30</span></span>
<span id="annotated-cell-16-2"><a href="#annotated-cell-16-2" aria-hidden="true" tabindex="-1"></a>states_visited <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, <span class="at">times =</span> max_iterations)</span>
<span id="annotated-cell-16-3"><a href="#annotated-cell-16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-16-4"><a href="#annotated-cell-16-4" aria-hidden="true" tabindex="-1"></a>iteration_counter <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-16" data-target-annotation="1">1</button><span id="annotated-cell-16-5" class="code-annotation-target"><a href="#annotated-cell-16-5" aria-hidden="true" tabindex="-1"></a>states_visited[<span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="st">"0.000"</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-16" data-target-annotation="2">2</button><span id="annotated-cell-16-6" class="code-annotation-target"><a href="#annotated-cell-16-6" aria-hidden="true" tabindex="-1"></a>current_state <span class="ot">&lt;-</span> <span class="st">"0.000"</span></span>
<span id="annotated-cell-16-7"><a href="#annotated-cell-16-7" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">479</span>)</span>
<span id="annotated-cell-16-8"><a href="#annotated-cell-16-8" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span>(current_state <span class="sc">!=</span> <span class="st">"3.000"</span> <span class="sc">&amp;</span> iteration_counter <span class="sc">&lt;</span> max_iterations){</span>
<span id="annotated-cell-16-9"><a href="#annotated-cell-16-9" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="annotated-cell-16-10"><a href="#annotated-cell-16-10" aria-hidden="true" tabindex="-1"></a>  current_state <span class="ot">&lt;-</span></span>
<span id="annotated-cell-16-11"><a href="#annotated-cell-16-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">sample</span>(unik_states<span class="sc">$</span>GameState, <span class="at">size =</span> <span class="dv">1</span>,</span>
<span id="annotated-cell-16-12"><a href="#annotated-cell-16-12" aria-hidden="true" tabindex="-1"></a>           <span class="at">prob =</span> transition_matrix[current_state,])</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-16" data-target-annotation="3">3</button><span id="annotated-cell-16-13" class="code-annotation-target"><a href="#annotated-cell-16-13" aria-hidden="true" tabindex="-1"></a>  iteration_counter <span class="ot">&lt;-</span> iteration_counter <span class="sc">+</span> <span class="dv">1</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-16" data-target-annotation="4">4</button><span id="annotated-cell-16-14" class="code-annotation-target"><a href="#annotated-cell-16-14" aria-hidden="true" tabindex="-1"></a>  states_visited[iteration_counter] <span class="ot">&lt;-</span> current_state</span>
<span id="annotated-cell-16-15"><a href="#annotated-cell-16-15" aria-hidden="true" tabindex="-1"></a>}</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-16" data-target-annotation="5">5</button><span id="annotated-cell-16-16" class="code-annotation-target"><a href="#annotated-cell-16-16" aria-hidden="true" tabindex="-1"></a>states_visited[<span class="dv">1</span><span class="sc">:</span>(iteration_counter)]</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-16" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-16" data-code-lines="5" data-code-annotation="1">The first state is always <code>0.000</code></span>
</dd>
<dt data-target-cell="annotated-cell-16" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-16" data-code-lines="6" data-code-annotation="2">Variable that keeps track of the current state of the Markov chain.</span>
</dd>
<dt data-target-cell="annotated-cell-16" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-16" data-code-lines="13" data-code-annotation="3">We increment <code>iteration_counter</code> as soon as we draw the next state</span>
</dd>
<dt data-target-cell="annotated-cell-16" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-16" data-code-lines="14" data-code-annotation="4">Save the next state in <code>states_visited</code></span>
</dd>
<dt data-target-cell="annotated-cell-16" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-16" data-code-lines="16" data-code-annotation="5">Only print out the states visited until the inning ends.</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "0.000" "0.010" "1.010" "2.010" "2.000" "3.000"</code></pre>
</div>
</div>
<p>This simulated half-inning consisted of 5 at-bats. The first at-bat started in state <code>0.000</code> and ended in <code>0.010</code>, which means that the first batter in the inning hit a double. The second at-bat started in state <code>0.010</code> but ended in <code>1.010</code>, which means that the second batter got out. Similarly, the third at-bat moved the game from <code>1.010</code> to <code>2.010</code>, which means that the third batter also got out. During the fourth simulated at-bat, however, the game state transitions from <code>2.010</code> to <code>2.000</code>. The only way for this to happen is for the batter to score and drive in the runner who was initially on second.</p>
</section>
<section id="sec-halfinning-length" class="level3">
<h3 class="anchored" data-anchor-id="sec-halfinning-length">Length of a Half-Inning</h3>
<p>Like we did in <a href="#sec-three-state" class="quarto-xref">Section&nbsp;3.2</a>, we can use simulation to estimate the distribution of the number of at-bats in a half-inning. Unlike that simulation, however, we will keep track of the whole sequence of states visited instead of the absorption time.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>n_sim <span class="ot">&lt;-</span> <span class="fl">5e4</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>max_iterations <span class="ot">&lt;-</span> <span class="dv">30</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>states_visited <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">nrow =</span> n_sim, <span class="at">ncol =</span> max_iterations)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(r <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n_sim){</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(<span class="dv">479</span><span class="sc">+</span>r)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  states_visited[r,<span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="st">"0.000"</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>  current_state <span class="ot">&lt;-</span> <span class="st">"0.000"</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  iteration_counter <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span>(current_state <span class="sc">!=</span> <span class="st">"3.000"</span> <span class="sc">&amp;</span> iteration_counter <span class="sc">&lt;</span> max_iterations){</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    current_state <span class="ot">&lt;-</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>      <span class="fu">sample</span>(<span class="at">x =</span> unik_states<span class="sc">$</span>GameState,</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>             <span class="at">size =</span> <span class="dv">1</span>, <span class="at">replace =</span> <span class="dv">1</span>,</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>             <span class="at">prob =</span> transition_matrix[current_state,])</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    iteration_counter <span class="ot">&lt;-</span> iteration_counter<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>    states_visited[r,iteration_counter] <span class="ot">&lt;-</span> current_state</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here are the first several rows of <code>states_visited</code>, which record the sequence of game states reached in some of our simulations</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>states_visited[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">8</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      [,1]    [,2]    [,3]    [,4]    [,5]    [,6]    [,7]    [,8]
 [1,] "0.000" "1.000" "2.000" "3.000" NA      NA      NA      NA  
 [2,] "0.000" "1.000" "2.000" "2.100" "3.000" NA      NA      NA  
 [3,] "0.000" "1.000" "1.100" "2.100" "2.011" "3.000" NA      NA  
 [4,] "0.000" "1.000" "2.000" "3.000" NA      NA      NA      NA  
 [5,] "0.000" "1.000" "1.100" "3.000" NA      NA      NA      NA  
 [6,] "0.000" "1.000" "2.000" "3.000" NA      NA      NA      NA  
 [7,] "0.000" "1.000" "2.000" "3.000" NA      NA      NA      NA  
 [8,] "0.000" "1.000" "2.000" "2.100" "3.000" NA      NA      NA  
 [9,] "0.000" "1.000" "1.100" "2.010" "2.100" "2.110" "3.000" NA  
[10,] "0.000" "0.010" "1.001" "1.100" "2.100" "3.000" NA      NA  </code></pre>
</div>
</div>
<p>We find, for instance, that in simulations 1, 4, 6, and 7, the pitching team retired the batting side in 3 at-bats. In Simulation 5, the last at-bat began in the state <code>1.100</code> and ended in <code>3.000</code>. From this we infer that the last at-bat involved an inning-ending double play.</p>
<p>To determine how many at-bats there were in each simulated half-inning, we will first determine which entry in every row is equal to <code>3.000</code>. In the case of simulation 1, for instance, <code>3.000</code> is the 4th entry of row 1. Since the inning ends as soon as the game enters the state <code>3.000</code>, we need to subtract one from this number to compute the number of at-bats in the half-inning.</p>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-19"><pre class="sourceCode r code-annotation-code code-with-copy"><code class="sourceCode r"><span id="annotated-cell-19-1"><a href="#annotated-cell-19-1" aria-hidden="true" tabindex="-1"></a>inning_length <span class="ot">&lt;-</span></span>
<span id="annotated-cell-19-2"><a href="#annotated-cell-19-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">apply</span>(states_visited, </span>
<span id="annotated-cell-19-3"><a href="#annotated-cell-19-3" aria-hidden="true" tabindex="-1"></a>        <span class="at">MARGIN =</span> <span class="dv">1</span>,</span>
<span id="annotated-cell-19-4"><a href="#annotated-cell-19-4" aria-hidden="true" tabindex="-1"></a>        <span class="at">FUN =</span> <span class="cf">function</span>(x){ <span class="fu">return</span>(<span class="fu">which</span>(x <span class="sc">==</span> <span class="st">"3.000"</span>) <span class="sc">-</span> <span class="dv">1</span>)} )</span>
<span id="annotated-cell-19-5"><a href="#annotated-cell-19-5" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(inning_length)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>inning_length
    3     4     5     6     7     8     9    10    11    12    13    14    15 
19138 14368  8685  4222  2014   921   401   131    72    31    11     4     2 </code></pre>
</div>
</div>
<p>In 19,138 of our 50,000 simulations, the inning ended after exactly 3 at-bats. And in 46413 the inning ended with 6 or fewer at-bats. Interestingly, there are two simulations in which the half-inning included 15 at-bats. Here is the sequence of states visited in that first simulation</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>states_visited[<span class="fu">which</span>(inning_length <span class="sc">==</span> <span class="dv">15</span>)[<span class="dv">1</span>], <span class="dv">1</span><span class="sc">:</span><span class="dv">15</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "0.000" "0.100" "0.110" "1.110" "1.000" "1.100" "1.000" "1.100" "1.000"
[10] "1.000" "1.100" "1.110" "1.101" "2.100" "2.000"</code></pre>
</div>
</div>
<p>In this simulated half-inning, the batting team drove in runs in the 4th, 6th, 7th, 8th, 9th, 13th, and 14th at-bats.</p>
</section>
<section id="sec-runs-scored" class="level3">
<h3 class="anchored" data-anchor-id="sec-runs-scored">Runs Scored in a Half-Inning</h3>
<p>To count how runs were scored in each of our 50,000 simulated half-innings, we need to determine how many runs were scored during each simulated at-bat. If we let <span class="math inline">\(O_{t}\)</span> and <span class="math inline">\(B_{t}\)</span> be the number of outs and runners at the <strong>start</strong> of at-bat <span class="math inline">\(t\)</span> and <span class="math inline">\(O^{\star}_{t}\)</span> and <span class="math inline">\(B^{\star}_{t}\)</span> be the numbers of outs and runners at the <strong>end</strong> of at-bat <span class="math inline">\(t\)</span>, it is not difficult to verify that the number of runs scored during at-bat <span class="math inline">\(t\)</span> is <span class="math display">\[
(O_{t} + B_{t} + 1) - (O_{t}^{\star} + B_{t}^{\star}).
\]</span> As an example, suppose at an at-bat starts in state <code>1.110</code> and ends in state <code>1.000</code>. The only way for such a transition to occur is for the batter to hit a homerun and drive in runs from 1st and 2nd base. That is, three runs are scored during such an at-bat. We verify that <span class="math inline">\(O_{t} = 1, B_{t} = 2, O_{t}^{\star} = 1\)</span> and <span class="math inline">\(B_{t}^{\star} = 0.\)</span> So, as expected <span class="math inline">\((O_{t} + B_{t} + 1) - (O_{t}^{\star} + B_{t}^{\star}) = 3.\)</span></p>
<p>We can elaborate our Markov chain simulation to count the number of runs scored in each at-bat. To do this, we will need to look up how many outs and baserunners there are based on each game-state. Rather than determining this programmatically, we can manually update the table <code>unik_states</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>unik_states <span class="ot">&lt;-</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  unik_states <span class="sc">|&gt;</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">mutate</span>(</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">n_runners =</span> </span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>      dplyr<span class="sc">::</span><span class="fu">case_when</span>(</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>        BaseRunner <span class="sc">==</span> <span class="st">"000"</span> <span class="sc">~</span> <span class="dv">0</span>,</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>        BaseRunner <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"100"</span>, <span class="st">"010"</span>, <span class="st">"001"</span>) <span class="sc">~</span> <span class="dv">1</span>,</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>        BaseRunner <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"110"</span>, <span class="st">"101"</span>, <span class="st">"011"</span>) <span class="sc">~</span> <span class="dv">2</span>,</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>        BaseRunner <span class="sc">==</span> <span class="st">"111"</span> <span class="sc">~</span> <span class="dv">3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We now elaborate our Markov chain simulation code to (i) get the number of outs and baserunners at the beginning and end of each simulated at-bat and (ii) add the number of runs scored in the at-bat to a running tally of runs scored in the half-inning.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p>This code takes several minutes. The lines looking up the number of outs and base-runners corresponding to each game state introduce some computational redundancies.</p>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-22"><pre class="sourceCode r code-annotation-code code-with-copy code-annotated"><code class="sourceCode r"><span id="annotated-cell-22-1"><a href="#annotated-cell-22-1" aria-hidden="true" tabindex="-1"></a>n_sim <span class="ot">&lt;-</span> <span class="fl">5e4</span></span>
<span id="annotated-cell-22-2"><a href="#annotated-cell-22-2" aria-hidden="true" tabindex="-1"></a>max_iterations <span class="ot">&lt;-</span> <span class="dv">30</span></span>
<span id="annotated-cell-22-3"><a href="#annotated-cell-22-3" aria-hidden="true" tabindex="-1"></a>states_visited <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">nrow =</span> n_sim, <span class="at">ncol =</span> max_iterations)</span>
<span id="annotated-cell-22-4"><a href="#annotated-cell-22-4" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-22" data-target-annotation="1">1</button><span id="annotated-cell-22-5" class="code-annotation-target"><a href="#annotated-cell-22-5" aria-hidden="true" tabindex="-1"></a>runs_scored <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, <span class="at">times =</span> n_sim)</span>
<span id="annotated-cell-22-6"><a href="#annotated-cell-22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-22-7"><a href="#annotated-cell-22-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(r <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n_sim){</span>
<span id="annotated-cell-22-8"><a href="#annotated-cell-22-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(<span class="dv">479</span><span class="sc">+</span>r)</span>
<span id="annotated-cell-22-9"><a href="#annotated-cell-22-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(r <span class="sc">%%</span> <span class="dv">5000</span> <span class="sc">==</span> <span class="dv">0</span>) <span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"Simulation"</span>, r, <span class="st">"at"</span>, <span class="fu">Sys.time</span>()))</span>
<span id="annotated-cell-22-10"><a href="#annotated-cell-22-10" aria-hidden="true" tabindex="-1"></a>  states_visited[r,<span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="st">"0.000"</span></span>
<span id="annotated-cell-22-11"><a href="#annotated-cell-22-11" aria-hidden="true" tabindex="-1"></a>  current_state <span class="ot">&lt;-</span> <span class="st">"0.000"</span></span>
<span id="annotated-cell-22-12"><a href="#annotated-cell-22-12" aria-hidden="true" tabindex="-1"></a>  iteration_counter <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-22" data-target-annotation="2">2</button><span id="annotated-cell-22-13" class="code-annotation-target"><a href="#annotated-cell-22-13" aria-hidden="true" tabindex="-1"></a>  runs <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="annotated-cell-22-14"><a href="#annotated-cell-22-14" aria-hidden="true" tabindex="-1"></a>  </span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-22" data-target-annotation="3">3</button><span id="annotated-cell-22-15" class="code-annotation-target"><a href="#annotated-cell-22-15" aria-hidden="true" tabindex="-1"></a>  n_outs_start <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="annotated-cell-22-16"><a href="#annotated-cell-22-16" aria-hidden="true" tabindex="-1"></a>  n_runners_start <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="annotated-cell-22-17"><a href="#annotated-cell-22-17" aria-hidden="true" tabindex="-1"></a>  n_outs_end <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="annotated-cell-22-18"><a href="#annotated-cell-22-18" aria-hidden="true" tabindex="-1"></a>  n_runners_end <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="annotated-cell-22-19"><a href="#annotated-cell-22-19" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="annotated-cell-22-20"><a href="#annotated-cell-22-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span>(current_state <span class="sc">!=</span> <span class="st">"3.000"</span> <span class="sc">&amp;</span> iteration_counter <span class="sc">&lt;</span> max_iterations){</span>
<span id="annotated-cell-22-21"><a href="#annotated-cell-22-21" aria-hidden="true" tabindex="-1"></a>    </span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-22" data-target-annotation="4">4</button><span id="annotated-cell-22-22" class="code-annotation-target"><a href="#annotated-cell-22-22" aria-hidden="true" tabindex="-1"></a>    n_outs_start <span class="ot">&lt;-</span></span>
<span id="annotated-cell-22-23"><a href="#annotated-cell-22-23" aria-hidden="true" tabindex="-1"></a>      unik_states <span class="sc">|&gt;</span> dplyr<span class="sc">::</span><span class="fu">filter</span>(GameState <span class="sc">==</span> current_state) <span class="sc">|&gt;</span> dplyr<span class="sc">::</span><span class="fu">pull</span>(Outs)</span>
<span id="annotated-cell-22-24"><a href="#annotated-cell-22-24" aria-hidden="true" tabindex="-1"></a>    n_runners_start <span class="ot">&lt;-</span></span>
<span id="annotated-cell-22-25"><a href="#annotated-cell-22-25" aria-hidden="true" tabindex="-1"></a>      unik_states <span class="sc">|&gt;</span> dplyr<span class="sc">::</span><span class="fu">filter</span>(GameState <span class="sc">==</span> current_state) <span class="sc">|&gt;</span> dplyr<span class="sc">::</span><span class="fu">pull</span>(n_runners)</span>
<span id="annotated-cell-22-26"><a href="#annotated-cell-22-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="annotated-cell-22-27"><a href="#annotated-cell-22-27" aria-hidden="true" tabindex="-1"></a>    current_state <span class="ot">&lt;-</span></span>
<span id="annotated-cell-22-28"><a href="#annotated-cell-22-28" aria-hidden="true" tabindex="-1"></a>      <span class="fu">sample</span>(<span class="at">x =</span> unik_states<span class="sc">$</span>GameState,</span>
<span id="annotated-cell-22-29"><a href="#annotated-cell-22-29" aria-hidden="true" tabindex="-1"></a>             <span class="at">size =</span> <span class="dv">1</span>, <span class="at">replace =</span> <span class="dv">1</span>,</span>
<span id="annotated-cell-22-30"><a href="#annotated-cell-22-30" aria-hidden="true" tabindex="-1"></a>             <span class="at">prob =</span> transition_matrix[current_state,])</span>
<span id="annotated-cell-22-31"><a href="#annotated-cell-22-31" aria-hidden="true" tabindex="-1"></a>    iteration_counter <span class="ot">&lt;-</span> iteration_counter<span class="sc">+</span><span class="dv">1</span></span>
<span id="annotated-cell-22-32"><a href="#annotated-cell-22-32" aria-hidden="true" tabindex="-1"></a>    states_visited[r,iteration_counter] <span class="ot">&lt;-</span> current_state</span>
<span id="annotated-cell-22-33"><a href="#annotated-cell-22-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="annotated-cell-22-34"><a href="#annotated-cell-22-34" aria-hidden="true" tabindex="-1"></a>    n_outs_end <span class="ot">&lt;-</span></span>
<span id="annotated-cell-22-35"><a href="#annotated-cell-22-35" aria-hidden="true" tabindex="-1"></a>      unik_states <span class="sc">|&gt;</span> dplyr<span class="sc">::</span><span class="fu">filter</span>(GameState <span class="sc">==</span> current_state) <span class="sc">|&gt;</span> dplyr<span class="sc">::</span><span class="fu">pull</span>(Outs)</span>
<span id="annotated-cell-22-36"><a href="#annotated-cell-22-36" aria-hidden="true" tabindex="-1"></a>    n_runners_end <span class="ot">&lt;-</span></span>
<span id="annotated-cell-22-37"><a href="#annotated-cell-22-37" aria-hidden="true" tabindex="-1"></a>      unik_states <span class="sc">|&gt;</span> dplyr<span class="sc">::</span><span class="fu">filter</span>(GameState <span class="sc">==</span> current_state) <span class="sc">|&gt;</span> dplyr<span class="sc">::</span><span class="fu">pull</span>(n_runners)</span>
<span id="annotated-cell-22-38"><a href="#annotated-cell-22-38" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-22" data-target-annotation="5">5</button><span id="annotated-cell-22-39" class="code-annotation-target"><a href="#annotated-cell-22-39" aria-hidden="true" tabindex="-1"></a>    runs <span class="ot">&lt;-</span></span>
<span id="annotated-cell-22-40"><a href="#annotated-cell-22-40" aria-hidden="true" tabindex="-1"></a>      runs <span class="sc">+</span></span>
<span id="annotated-cell-22-41"><a href="#annotated-cell-22-41" aria-hidden="true" tabindex="-1"></a>      (n_outs_start <span class="sc">+</span> n_runners_start <span class="sc">+</span> <span class="dv">1</span>) <span class="sc">-</span></span>
<span id="annotated-cell-22-42"><a href="#annotated-cell-22-42" aria-hidden="true" tabindex="-1"></a>      (n_outs_end <span class="sc">+</span> n_runners_end)</span>
<span id="annotated-cell-22-43"><a href="#annotated-cell-22-43" aria-hidden="true" tabindex="-1"></a>  }</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-22" data-target-annotation="6">6</button><span id="annotated-cell-22-44" class="code-annotation-target"><a href="#annotated-cell-22-44" aria-hidden="true" tabindex="-1"></a>  runs_scored[r] <span class="ot">&lt;-</span> runs</span>
<span id="annotated-cell-22-45"><a href="#annotated-cell-22-45" aria-hidden="true" tabindex="-1"></a>}</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-22" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-22" data-code-lines="5" data-code-annotation="1">Container to save the number of runs scored in each simulated half-inning</span>
</dd>
<dt data-target-cell="annotated-cell-22" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-22" data-code-lines="13" data-code-annotation="2">Variable that will store the running tally of runs scored</span>
</dd>
<dt data-target-cell="annotated-cell-22" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-22" data-code-lines="15,16,17,18" data-code-annotation="3">Temporary variables storing the numbers of outs and baserunners at the start and end of an at-bat</span>
</dd>
<dt data-target-cell="annotated-cell-22" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-22" data-code-lines="22,23,24,25,34,35,36,37" data-code-annotation="4">At the start of a simulated at-bat, get the numbers of outs and runners</span>
</dd>
<dt data-target-cell="annotated-cell-22" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-22" data-code-lines="39,40,41,42" data-code-annotation="5">At the end of a simulated at-bat, get the numbers of outs and runners</span>
</dd>
<dt data-target-cell="annotated-cell-22" data-target-annotation="6">6</dt>
<dd>
<span data-code-cell="annotated-cell-22" data-code-lines="44" data-code-annotation="6">Add the number of runs scored in the current at-bat to the running tally</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Simulation 5000 at 2025-10-12 10:33:33.501278"
[1] "Simulation 10000 at 2025-10-12 10:34:04.4989"
[1] "Simulation 15000 at 2025-10-12 10:34:35.688561"
[1] "Simulation 20000 at 2025-10-12 10:35:07.392822"
[1] "Simulation 25000 at 2025-10-12 10:35:38.505577"
[1] "Simulation 30000 at 2025-10-12 10:36:09.795408"
[1] "Simulation 35000 at 2025-10-12 10:36:41.31038"
[1] "Simulation 40000 at 2025-10-12 10:37:12.930233"
[1] "Simulation 45000 at 2025-10-12 10:37:45.754027"
[1] "Simulation 50000 at 2025-10-12 10:38:17.400918"</code></pre>
</div>
</div>
<p>We can now tabulate the number of runs scored in each simulated half-inning</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(runs_scored)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>runs_scored
    0     1     2     3     4     5     6     7     8     9    10    11    12 
19138 14368  8685  4222  2014   921   401   131    72    31    11     4     2 </code></pre>
</div>
</div>
</section>
</section>
<section id="sec-nstep" class="level2">
<h2 class="anchored" data-anchor-id="sec-nstep">Modeling Multiple Steps</h2>
<p>The <span class="math inline">\((s,s')\)</span> entry of <span class="math inline">\(\boldsymbol{\mathbf{P}}\)</span> is the probability that the chain moves from state <span class="math inline">\(s\)</span> to state <span class="math inline">\(s'.\)</span> Based on the 2024 MLB season, we estimated that approximately 23% of at-bats that began in the state <code>1.000</code> ended in the state <code>1.100</code>, so <span class="math inline">\(p_{\textrm{1.000, 1.100}} \approx 0.23\)</span></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>transition_matrix[<span class="st">"1.000"</span>, <span class="st">"1.100"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.2306792</code></pre>
</div>
</div>
<p>Now suppose we are at the start of an at-bat with one out and no runners on base (i.e., in state <code>1.000</code>). How likely is it that in exactly two at-bats, we will have two outs and a runner on 1st base (i.e., be in the state <code>2.100</code>)?</p>
<p>Before answering this question, we consider a somewhat simpler question: What are all the different intermediate states that the game could visit between <code>1.000</code> and <code>2.100</code>? For instance, the batter facing <code>1.000</code> could strike out, moving the game to <code>2.000</code>, and then the next batter could hit a single, moving the game to <code>2.100</code>. Alternatively, the batter facing <code>1.000</code> could hit a single, moving the game to <code>1.100</code>, before the next batter strikes out, moving the game to <code>2.100</code>. A somewhat less likely — but still plausible — way to reach <code>2.100</code> from <code>1.000</code> in two at-bats is for the first batter to hit a single and for the second batter to hit into a force out at second.</p>
<p>More formally, to compute the probability that the game moves from <code>1.000</code> to <code>2.100</code> in exactly two steps, we must</p>
<ol type="1">
<li>Multiply the one-step transition probabilities <span class="math inline">\(p_{\textrm{1.000},s} \times p_{s, \textrm{2.100}}\)</span> to obtain the probability of transitioning from <code>1.000</code> to <span class="math inline">\(s\)</span> to <code>2.100</code> <strong>for all states <span class="math inline">\(s\)</span></strong>.</li>
<li>Sum these two-step probabilities over all possibly intermediate states <span class="math inline">\(s.\)</span></li>
</ol>
<p>That is, we compute <span class="math display">\[
\mathbb{P}(\textrm{game moves from 1.000 to 2.100 in two steps}) = \sum_{s}{p_{\textrm{1.000},s} \times p_{s, \textrm{2.100}}},
\]</span> where the sum is taken over <em>all</em> possible states. Because certain states like <code>0.000</code> or <code>3.000</code> are unreachable from <code>1.000</code>, the impossible transitions through those states do not contribute to the sum as the term <span class="math inline">\(p_{1.000,s}\)</span> will be zero.</p>
<p>Looking carefully at this sum, we recognize the familiar form of matrix multiplication. Specifically, the entry corresponding to (<code>1.000,2.100</code>) in the matrix <span class="math inline">\(\boldsymbol{\mathbf{P}} \times \boldsymbol{\mathbf{P}}\)</span> is <em>precisely</em> the sum above. We find that there is roughly a 26% probability of reaching <code>2.100</code> from <code>1.000</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="annotated-cell-25"><pre class="sourceCode r code-annotation-code code-with-copy code-annotated"><code class="sourceCode r"><button class="code-annotation-anchor" data-target-cell="annotated-cell-25" data-target-annotation="1">1</button><span id="annotated-cell-25-1" class="code-annotation-target"><a href="#annotated-cell-25-1" aria-hidden="true" tabindex="-1"></a>P2 <span class="ot">&lt;-</span> transition_matrix <span class="sc">%*%</span> transition_matrix</span>
<span id="annotated-cell-25-2"><a href="#annotated-cell-25-2" aria-hidden="true" tabindex="-1"></a>P2[<span class="st">"1.000"</span>, <span class="st">"2.100"</span>]</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-25" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-25" data-code-lines="1" data-code-annotation="1">Matrix multiplication uses the syntax <code>%*%</code></span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] NA</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition: n-Step Transition
</div>
</div>
<div class="callout-body-container callout-body">
<p>For any integer <span class="math inline">\(n\)</span>, let <span class="math inline">\(\boldsymbol{\mathbf{P}}^{n}\)</span> denote the <strong><span class="math inline">\(n\)</span>-step transition matrix</strong>, which we obtain by multiplying <span class="math inline">\(\boldsymbol{\mathbf{P}}\)</span> with itself <span class="math inline">\(n\)</span> times. The <span class="math inline">\((s,s')\)</span> entry of <span class="math inline">\(\boldsymbol{\mathbf{P}}^{n}\)</span> is the probability that Markov chain beginning in state <span class="math inline">\(s\)</span> reaches states <span class="math inline">\(s'\)</span> in <em>exactly</em> <span class="math inline">\(n\)</span> steps.</p>
</div>
</div>
<p>To illustrate, here are several entries of <span class="math inline">\(\boldsymbol{\mathbf{P}}^{2}\)</span></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>selected_states <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"0.000"</span>, <span class="st">"1.000"</span>, <span class="st">"2.000"</span>, <span class="st">"1.110"</span>, <span class="st">"3.000"</span>)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(P2[selected_states, selected_states], <span class="at">digits =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      0.000 1.000 2.000 1.110 3.000
0.000    NA    NA    NA    NA    NA
1.000    NA    NA    NA    NA    NA
2.000    NA    NA    NA    NA    NA
1.110    NA    NA    NA    NA    NA
3.000    NA    NA    NA    NA    NA</code></pre>
</div>
</div>
<p>Starting from <code>0.000</code>, there is about a 50% chance that the game reaches the state <code>2.000</code> after two at-bats<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. Similarly, there is about a 50% chance that the inning ends within two batters of an at-bat beginning in state <code>1.000</code>. Looking at the three-step transition probabilities, we see that the most three most likely outcomes after the first three batters of a half-inning are (i) the inning ended (38%); (ii) the state <code>2.100</code> (23.5%); and (iii) the state <code>2.010</code> (7.8%)</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>P3 <span class="ot">&lt;-</span> P2 <span class="sc">%*%</span> transition_matrix</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(<span class="fu">sort</span>(P3[<span class="st">"0.000"</span>,], <span class="at">decreasing =</span> <span class="cn">TRUE</span>), <span class="at">digits =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>named numeric(0)</code></pre>
</div>
</div>
</section>
<section id="sec-absorbing" class="level2">
<h2 class="anchored" data-anchor-id="sec-absorbing">Theory of Absorbing Markov Chains</h2>
<p>Now, we turn to a more nuanced questions: starting from state <code>1.100</code>, what is the probability that we visit the state <code>2.010</code> before the end of the half-inning? And about how many times can we visit the state <code>2.010</code> before the half-inning ends? To answer these questions, we need to introduce a bit more theory about Markov chains.</p>
<p>First, recall that in our Markov chain model of a half-inning, the state <code>3.000</code> is <strong>absorbing</strong>: once the chain reaches the state (i.e., the inning ends), it remains there and cannot visit any of the other states.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition: Absorbing Markov Chain
</div>
</div>
<div class="callout-body-container callout-body">
<p>A Markov chain is called <strong>absorbing</strong> if it (i) there is at least one absorbing state and (ii) it is possible to go from any state to an absorbing state in a finite number of steps.</p>
</div>
</div>
<p>It is not difficult to verify mathematically that our Markov chain for the state transitions between at-bats is absorbing. But it is even easier to verify this empirically: in all of baseball, we’ve never not had a half-inning continue indefinitely. Eventually all half-innings ends, reaching the absorbing state <code>3.000</code>.</p>
<p>Now, suppose we have an absorbing Markov chain defined over the states <span class="math inline">\(\{1, 2, \ldots, S\}.\)</span> Without losing any generality, let us suppose that the first <span class="math inline">\(T\)</span> states are non-absorbing and the last <span class="math inline">\(A = S - T\)</span> states are absorbing. Then, the transition matrix has the form <span class="math display">\[
\boldsymbol{\mathbf{P}} = \begin{pmatrix} Q &amp; R \\ 0 &amp; I_{A} \end{pmatrix},
\]</span> where <span class="math inline">\(Q\)</span> is a <span class="math inline">\(T \times T\)</span> matrix capturing one-step transition probabilities between non-absorbing states; <span class="math inline">\(R\)</span> is a <span class="math inline">\(T \times A\)</span> matrix capturing one-step transition probabilities between non-absorbing and absorbing states; and <span class="math inline">\(I_{A}\)</span> is the <span class="math inline">\(A \times A\)</span> identity matrix, with ones along the diagonal and zeros in all other entries.</p>
<p>In our baseball example, there is only <span class="math inline">\(A = 1\)</span> absorbing state and <span class="math inline">\(T = 24\)</span> non-absorbing states. The code below extracts the matrix <span class="math inline">\(Q\)</span></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>transient_states <span class="ot">&lt;-</span> unik_states <span class="sc">|&gt;</span> dplyr<span class="sc">::</span><span class="fu">filter</span>(GameState <span class="sc">!=</span> <span class="st">"3.000"</span>) <span class="sc">|&gt;</span> dplyr<span class="sc">::</span><span class="fu">pull</span>(GameState)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>Q <span class="ot">&lt;-</span> transition_matrix[transient_states, transient_states]</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>R <span class="ot">&lt;-</span> <span class="fu">matrix</span>(transition_matrix[transient_states, <span class="st">"3.000"</span>], <span class="at">ncol =</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition: Fundamental Matrix
</div>
</div>
<div class="callout-body-container callout-body">
<p>For an absorbing Markov chain, the <strong>fundamental</strong> matrix is given by <span class="math display">\[
N = (I_{T} - Q)^{-1}.
\]</span></p>
</div>
</div>
<p>For any two transient states <span class="math inline">\(s\)</span> and <span class="math inline">\(s',\)</span> the <span class="math inline">\((s,s')\)</span> entry of <span class="math inline">\(N,\)</span> which we denote as <span class="math inline">\(n_{s,s'}\)</span> counts the <em>expected</em> number of times visits state <span class="math inline">\(s'\)</span> after starting from <span class="math inline">\(s\)</span> before absorption.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="fu">solve</span>(<span class="fu">diag</span>(<span class="dv">24</span>) <span class="sc">-</span> Q)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(N[<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>], <span class="at">digits =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      0.000 0.100 0.010 0.001 0.110
0.000  1.05  0.25  0.06  0.01  0.06
0.100  0.05  1.02  0.03  0.01  0.22
0.010  0.04  0.07  1.06  0.01  0.13
0.001  0.06  0.20  0.06  1.01  0.06
0.110  0.05  0.02  0.02  0.01  1.06</code></pre>
</div>
</div>
<p>Looking at several entries of the fundamental matrix of our baseball Markov chain, we notice a few things. First, starting from <code>0.000</code>, we expect the number of times the chain visits <code>0.100</code> about 0.25 times and <code>0.010</code> 0.06 times, on average. We also observe that the diagonal entries all appear to be larger than 1.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(<span class="fu">diag</span>(N), <span class="at">digits  =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>0.000 0.100 0.010 0.001 0.110 0.101 0.011 0.111 1.000 1.100 1.010 1.001 1.110 
 1.05  1.02  1.06  1.01  1.06  1.06  1.02  1.19  1.04  1.02  1.06  1.01  1.06 
1.101 1.011 1.111 2.000 2.100 2.010 2.001 2.110 2.101 2.011 2.111 
 1.06  1.02  1.19  1.04  1.03  1.07  1.01  1.06  1.07  1.01  1.17 </code></pre>
</div>
</div>
<p>Recall that the diagonal entry <span class="math inline">\(n_{s,s}\)</span> is the expected number of times that an absorbing chain visits state <span class="math inline">\(s\)</span> after starting from state <span class="math inline">\(s.\)</span> So, if the chain <em>starts</em> at <span class="math inline">\(s,\)</span> it necessarily visits <span class="math inline">\(s\)</span> at least once. These results suggest, for instance, that starting from the state <code>1.111</code> the chain will return to the state <code>1.111</code> about 0.19 more times, on average. Similarly, starting from <code>0.000</code>, the chain expects to return to the starting state <code>0.000</code> only 0.05 more times, on average.</p>
<p>Summing the entries along the rows of <span class="math inline">\(N\)</span>, we can compute the expected time until the chain is absorbed starting from each state. So, if we are in an at-bat starting with <code>1.000</code>, we would expect to face a total of 1.84 <em>additional</em> batters before the end of the half-inning</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span>(N[<span class="st">"1.000"</span>,])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2.843932</code></pre>
</div>
</div>
</section>
<section id="sec-looking-ahead" class="level2">
<h2 class="anchored" data-anchor-id="sec-looking-ahead">Looking Ahead</h2>
<!--
In [Lecture 15](lecture15.qmd), we will lean on some mathematical properties of Markov chains to  understand how many more at-bats a team can expect to have in a half-inning given the current game state.
We will then estimate team-specific transition probability matrices, which will enable somewhat more granular Markov chain simulations.
So that we don't have to re-compute it, we will save the transition matrix and the set of unique states

::: {.cell}

```{.r .cell-code}
save(transition_matrix, unik_states, file = "atbat2024_markov_chain.RData")
```
:::

-->
</section>
<section id="exercises" class="level2">
<h2 class="anchored" data-anchor-id="exercises">Exercises</h2>
<ol type="1">
<li>When simulating the number of runs scored in the half-inning, we initialized our Markov chains from <code>0.000</code>, which is the state at the start of every half-inning. By initializing at some other state — say <code>1.000</code> — we can study the distribution of runs scored <strong>after</strong> an at-bat beginning in that state. Use a Markov chain simulation to estimate the run expectancy for every state and compare it to the matrix we estimated in <a href="../lectures/lecture06.html">Lecture 6</a>.</li>
</ol>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>It is possible to construct Markov chains where some absorbing states are never reached from certain initial states. Without a stopping criterion based on the number of iterations, the <code>while()</code> could continue indefinitely.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>For instance, if the home team begins the bottom of the 9th inning tied and their first batter hits a homerun, then the game ends immediately.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Reassuringly, we see that there is a a 0% chance of the inning ending after two at-bats!<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
        for (let i=0; i<annoteTargets.length; i++) {
          const annoteTarget = annoteTargets[i];
          const targetCell = annoteTarget.getAttribute("data-target-cell");
          const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
          const contentFn = () => {
            const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
            if (content) {
              const tipContent = content.cloneNode(true);
              tipContent.classList.add("code-annotation-tip-content");
              return tipContent.outerHTML;
            }
          }
          const config = {
            allowHTML: true,
            content: contentFn,
            onShow: (instance) => {
              selectCodeLines(instance.reference);
              instance.reference.classList.add('code-annotation-active');
              window.tippy.hideAll();
            },
            onHide: (instance) => {
              unselectCodeLines();
              instance.reference.classList.remove('code-annotation-active');
            },
            maxWidth: 300,
            delay: [50, 0],
            duration: [200, 0],
            offset: [5, 10],
            arrow: true,
            appendTo: function(el) {
              return el.parentElement.parentElement.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'quarto',
            placement: 'right',
            popperOptions: {
              modifiers: [
              {
                name: 'flip',
                options: {
                  flipVariations: false, // true by default
                  allowedAutoPlacements: ['right'],
                  fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
                },
              },
              {
                name: 'preventOverflow',
                options: {
                  mainAxis: false,
                  altAxis: false
                }
              }
              ]        
            }      
          };
          window.tippy(annoteTarget, config); 
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>