[
  {
    "objectID": "lectures/lecture4.html",
    "href": "lectures/lecture4.html",
    "title": "Lecture 4: Wins above Replacement I",
    "section": "",
    "text": "Expected runs framework",
    "crumbs": [
      "Lecture 4: Wins above Replacement I"
    ]
  },
  {
    "objectID": "lectures/lecture4.html#overview",
    "href": "lectures/lecture4.html#overview",
    "title": "Lecture 4: Wins above Replacement I",
    "section": "",
    "text": "Expected runs framework",
    "crumbs": [
      "Lecture 4: Wins above Replacement I"
    ]
  },
  {
    "objectID": "lectures/lecture4.html#from-pitch-by-pitch-to-plate-appearance",
    "href": "lectures/lecture4.html#from-pitch-by-pitch-to-plate-appearance",
    "title": "Lecture 4: Wins above Replacement I",
    "section": "From pitch-by-pitch to plate appearance",
    "text": "From pitch-by-pitch to plate appearance",
    "crumbs": [
      "Lecture 4: Wins above Replacement I"
    ]
  },
  {
    "objectID": "lectures/lecture4.html#expected-runs",
    "href": "lectures/lecture4.html#expected-runs",
    "title": "Lecture 4: Wins above Replacement I",
    "section": "Expected Runs",
    "text": "Expected Runs\n\n\nAdjusting for platoon advantages & park effects",
    "crumbs": [
      "Lecture 4: Wins above Replacement I"
    ]
  },
  {
    "objectID": "lectures/lecture4.html#base-running",
    "href": "lectures/lecture4.html#base-running",
    "title": "Lecture 4: Wins above Replacement I",
    "section": "Base-running",
    "text": "Base-running\nQuote from Baumer et al. “baserunners should only get credit for advancement beyond what would be expected given their starting locations, number of outs, and the hitting event that occurred”  ### Expected base advancement",
    "crumbs": [
      "Lecture 4: Wins above Replacement I"
    ]
  },
  {
    "objectID": "lectures/lecture4.html#batting",
    "href": "lectures/lecture4.html#batting",
    "title": "Lecture 4: Wins above Replacement I",
    "section": "Batting",
    "text": "Batting",
    "crumbs": [
      "Lecture 4: Wins above Replacement I"
    ]
  },
  {
    "objectID": "lectures/lecture2.html",
    "href": "lectures/lecture2.html",
    "title": "Lecture 2: Expected Goals in Soccer",
    "section": "",
    "text": "Consider the following goals scored by Beth Meade during EURO 2022.\n\n\n\n\n\n\n\nWe can make these statements more quantiatively precise using expected goals\nDefinition of xG",
    "crumbs": [
      "Lecture 2: Expected Goals in Soccer"
    ]
  },
  {
    "objectID": "lectures/lecture2.html#motivation-beth-meades-performance-at-euro2022",
    "href": "lectures/lecture2.html#motivation-beth-meades-performance-at-euro2022",
    "title": "Lecture 2: Expected Goals in Soccer",
    "section": "",
    "text": "Consider the following goals scored by Beth Meade during EURO 2022.\n\n\n\n\n\n\n\nWe can make these statements more quantiatively precise using expected goals\nDefinition of xG",
    "crumbs": [
      "Lecture 2: Expected Goals in Soccer"
    ]
  },
  {
    "objectID": "lectures/lecture2.html#digression-conditional-probability",
    "href": "lectures/lecture2.html#digression-conditional-probability",
    "title": "Lecture 2: Expected Goals in Soccer",
    "section": "Digression: Conditional Probability",
    "text": "Digression: Conditional Probability",
    "crumbs": [
      "Lecture 2: Expected Goals in Soccer"
    ]
  },
  {
    "objectID": "lectures/lecture2.html#working-with-statsbombs-xg",
    "href": "lectures/lecture2.html#working-with-statsbombs-xg",
    "title": "Lecture 2: Expected Goals in Soccer",
    "section": "Working with StatsBomb’s XG",
    "text": "Working with StatsBomb’s XG\n\nAs an illustration, here is a visualization of all of Beth Meade’s shots along with the associated XG value. Notice that some are very low and some are very high.",
    "crumbs": [
      "Lecture 2: Expected Goals in Soccer"
    ]
  },
  {
    "objectID": "lectures/lecture2.html#goals-above-expected-team-based",
    "href": "lectures/lecture2.html#goals-above-expected-team-based",
    "title": "Lecture 2: Expected Goals in Soccer",
    "section": "Goals Above Expected (Team-Based)",
    "text": "Goals Above Expected (Team-Based)",
    "crumbs": [
      "Lecture 2: Expected Goals in Soccer"
    ]
  },
  {
    "objectID": "lectures/lecture2.html#goals-above-expected-player-based",
    "href": "lectures/lecture2.html#goals-above-expected-player-based",
    "title": "Lecture 2: Expected Goals in Soccer",
    "section": "Goals Above Expected (Player-Based)",
    "text": "Goals Above Expected (Player-Based)\n\nMathematically, let \\(Y_{ij}\\) be the outcome of shot \\(j\\) taken by player \\(i\\) with \\(Y_{ij} = 1\\) if a goal is scored off that shot and \\(Y_{ij} = 0\\) otherwise. Additionally \\(\\textrm{XG}_{ij}\\) be the corresponding XG value for that shot.\nWe can compute the difference \\(y_{ij} - \\textrm{xg}_{ij}\\) for each shot that player \\(i\\) takes",
    "crumbs": [
      "Lecture 2: Expected Goals in Soccer"
    ]
  },
  {
    "objectID": "lectures/lecture1.html",
    "href": "lectures/lecture1.html",
    "title": "Lecture 1: Boxscore Metrics",
    "section": "",
    "text": "Who is the best shooter in the NBA?\nHow do we determine this using data? \n\n\nWhile they may be predictive, box score metrics are primarily retrospective: they tell (part of) the story of what happened.\n\n\n\nIn this lecture, we will practice using functions from the tidyverse suite of packages (especially dplyr) to manipulate tables of NBA box score data. Hopefully, much of the functionality we encounter in this lecture will be familiar to you. But, if you need a high-level refresher, I highly recommend the following resources:\n\nChapter 3 and Chapter 5 of R for Data Science.\nSection 1.9 and Chapter 3 of *Data Science: A First Introduction.\n\nWe will use\n\n\n\n\n\n\nSystem setup\n\n\n\n\n\nFor this lecture, we will use a new R package to scrape NBA boxscore data. In order to do this, it is critical that you have already installed the devtools package, as noted in the Getting Started guide. To check that you have successfully installed the package, run the following code.\n\nif(!\"devtools\" %in% rownames(installed.packages())){\n  stop(\"devtools not installed\")\n}",
    "crumbs": [
      "Lecture 1: Boxscore Metrics"
    ]
  },
  {
    "objectID": "lectures/lecture1.html#overview",
    "href": "lectures/lecture1.html#overview",
    "title": "Lecture 1: Boxscore Metrics",
    "section": "",
    "text": "Who is the best shooter in the NBA?\nHow do we determine this using data? \n\n\nWhile they may be predictive, box score metrics are primarily retrospective: they tell (part of) the story of what happened.\n\n\n\nIn this lecture, we will practice using functions from the tidyverse suite of packages (especially dplyr) to manipulate tables of NBA box score data. Hopefully, much of the functionality we encounter in this lecture will be familiar to you. But, if you need a high-level refresher, I highly recommend the following resources:\n\nChapter 3 and Chapter 5 of R for Data Science.\nSection 1.9 and Chapter 3 of *Data Science: A First Introduction.\n\nWe will use\n\n\n\n\n\n\nSystem setup\n\n\n\n\n\nFor this lecture, we will use a new R package to scrape NBA boxscore data. In order to do this, it is critical that you have already installed the devtools package, as noted in the Getting Started guide. To check that you have successfully installed the package, run the following code.\n\nif(!\"devtools\" %in% rownames(installed.packages())){\n  stop(\"devtools not installed\")\n}",
    "crumbs": [
      "Lecture 1: Boxscore Metrics"
    ]
  },
  {
    "objectID": "lectures/lecture1.html#basic-box-score-statistics",
    "href": "lectures/lecture1.html#basic-box-score-statistics",
    "title": "Lecture 1: Boxscore Metrics",
    "section": "Basic box score statistics",
    "text": "Basic box score statistics\n\nScraping and wrangling box score data\nWe will scrape NBA box score data using the hoopR package. We start by installing the package.\n\nif(!\"hoopR\" %in% rownames(installed.packages())){\n  message(\"Package `hoopR' is not currently installed. Installing now\")\n  devtools::install_github(repo = \"sportsdataverse/hoopR\")\n}\nlibrary(tidyverse) # load the tidyverse suite of packages\n\nYou can read more about the package here. One important function is load_nba_player_box, which scrapes individual player’s box score for every game.\n\nraw_box &lt;-\n  hoopR::load_nba_player_box(seasons = 2002:(hoopR::most_recent_nba_season()))\n\nTo study shooting ability, we need to aggregate the individual game-level data into season-level totals. Conceptually, we can accomplish this by first dividing the full data table into several smaller tables, one for each combination of player and season. Then, we can sum the number of field goals, three point shots, and free throws attempted and made by each player in each of their season. This order of operations is an example of the split-apply-combine paradigm, which is implemented in dplyr using group_by.\n\n\nseason_box &lt;-\n  raw_box %&gt;%\n  select(season, season_type, \n         athlete_display_name,\n         minutes, \n         field_goals_made, field_goals_attempted,\n         three_point_field_goals_made, three_point_field_goals_attempted,\n         free_throws_made, free_throws_attempted,\n         did_not_play) %&gt;%\n  rename(\n    Player = athlete_display_name,\n    FGM = field_goals_made,\n    FGA = field_goals_attempted,\n    TPM = three_point_field_goals_made,\n    TPA = three_point_field_goals_attempted,\n    FTM = free_throws_made, \n    FTA = free_throws_attempted) %&gt;%\n  filter(!did_not_play) %&gt;%\n  filter(season_type == 2) %&gt;%\n  filter(!(is.na(FGA) & is.na(TPA) & is.na(FTA))) %&gt;% # filter out missing data records\n  group_by(Player, season) %&gt;%\n  summarise(\n    FGM = sum(FTM),\n    FGA = sum(FGA),\n    TPM = sum(TPM),\n    TPA = sum(TPA),\n    FTM = sum(FTM),\n    FTA = sum(FTA),\n    minutes = sum(minutes),\n    n_games = n(),\n    .groups = \"drop\") %&gt;%\n  filter(FGM &lt;= FGA)\n\nWe have data for 11766 player-seasons across 2403 players. Here is a quick snapshot of the data for one player.\n\nseason_box %&gt;%\n  filter(Player == \"Dirk Nowitzki\")\n\n# A tibble: 18 × 10\n   Player        season minutes n_games   FGM   FGA   TPM   TPA   FTM   FTA\n   &lt;chr&gt;          &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1 Dirk Nowitzki   2002    3248      84   505  1422   155   378   505   590\n 2 Dirk Nowitzki   2003    3839      97   586  1802   175   451   586   661\n 3 Dirk Nowitzki   2004    3127      82   407  1410   106   305   407   465\n 4 Dirk Nowitzki   2005    3571      91   707  1701   101   258   707   819\n 5 Dirk Nowitzki   2006    4069     104   744  1983   133   338   744   827\n 6 Dirk Nowitzki   2007    3058      84   540  1435    76   192   540   601\n 7 Dirk Nowitzki   2008    2980      82   520  1405    85   238   520   596\n 8 Dirk Nowitzki   2009    3446      91   571  1786    67   191   571   638\n 9 Dirk Nowitzki   2010    3273      87   576  1602    55   128   576   628\n10 Dirk Nowitzki   2011    3331      94   570  1575    89   218   570   629\n11 Dirk Nowitzki   2012    2231      66   356  1111    79   218   356   397\n12 Dirk Nowitzki   2013    1628      52   164   707    63   151   164   191\n13 Dirk Nowitzki   2014    2896      88   363  1401   132   342   363   407\n14 Dirk Nowitzki   2015    2478      83   281  1151   109   293   281   317\n15 Dirk Nowitzki   2016    2533      80   266  1195   130   353   266   297\n16 Dirk Nowitzki   2017    1421      54    98   678    79   209    98   112\n17 Dirk Nowitzki   2018    1901      77    97   758   138   337    97   108\n18 Dirk Nowitzki   2019     798      52    39   379    67   208    39    50\n\n\n\n\nFrom totals to percentages\nOne way to define the best shooter is to identify the player who made the most shots. We can identify this by arranging our data table in descending order.\n\nseason_box %&gt;%\n  arrange(desc(FGM))\n\n# A tibble: 11,808 × 10\n   Player             season minutes n_games   FGM   FGA   TPM   TPA   FTM   FTA\n   &lt;chr&gt;               &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1 James Harden         2015    3640      99   878  1780   256   674   878  1002\n 2 James Harden         2017    3391      93   847  1760   298   880   847   996\n 3 Kevin Durant         2014    3967     101   839  2137   241   633   839   972\n 4 James Harden         2019    3320      90   836  2186   430  1178   836   956\n 5 Kevin Durant         2010    3472      88   810  1791   138   386   810   902\n 6 James Harden         2020    2943      81   792  1751   341   969   792   920\n 7 Dwyane Wade          2006    3617      92   783  1736    24   106   783   990\n 8 Kobe Bryant          2008    4057     103   780  2153   182   521   780   936\n 9 Shai Gilgeous-Ale…   2025    3426     100   777  2151   198   549   777   872\n10 Russell Westbrook    2017    3017      87   768  2119   220   645   768   912\n# ℹ 11,798 more rows\n\n\n\nTo make this more precise, we can compute the field goal percentage (and similarly for three pointers and free throws).\n\nseason_box &lt;-\n  season_box %&gt;%\n  mutate(\n    FGP = ifelse(FGA &gt; 0, FGM/FGA, NA_real_),\n    TPP = ifelse(TPA &gt; 0, TPM/TPA, NA_real_),\n    FTP = ifelse(FTA &gt; 0, FTM/FTA, NA_real_))\n\n\nseason_box %&gt;% \n  arrange(desc(FGP)) %&gt;%\n  select(Player, season, FGP)\n\n# A tibble: 11,766 × 3\n   Player             season   FGP\n   &lt;chr&gt;               &lt;int&gt; &lt;dbl&gt;\n 1 Alvin Williams       2007     1\n 2 Andris Biedrins      2014     1\n 3 Chandler Hutchison   2022     1\n 4 Chuck Hayes          2016     1\n 5 Daishen Nix          2025     1\n 6 Dajuan Wagner        2007     1\n 7 Ike Diogu            2012     1\n 8 Jared Harper         2021     1\n 9 Jarnell Stokes       2017     1\n10 Jelani McCoy         2008     1\n# ℹ 11,756 more rows\n\n\nSorting the players by their \\(\\textrm{FGP},\\) we find that several players made 100% of their field goals. But very few of these players are immediately recognizable — and, indeed, none of them have been in the MVP conversation, despite the fact that they made all their shots!\nTo understand what’s going on, let’s take a look at the number of attempts and the number of games played.\n\nseason_box %&gt;% \n  arrange(desc(FGP)) %&gt;%\n  select(Player, season, FGP, n_games, FGA)\n\n# A tibble: 11,766 × 5\n   Player             season   FGP n_games   FGA\n   &lt;chr&gt;               &lt;int&gt; &lt;dbl&gt;   &lt;int&gt; &lt;int&gt;\n 1 Alvin Williams       2007     1       2     2\n 2 Andris Biedrins      2014     1       6     1\n 3 Chandler Hutchison   2022     1       6     2\n 4 Chuck Hayes          2016     1       2     2\n 5 Daishen Nix          2025     1       3     1\n 6 Dajuan Wagner        2007     1       1     1\n 7 Ike Diogu            2012     1       2     2\n 8 Jared Harper         2021     1       8     3\n 9 Jarnell Stokes       2017     1       2     1\n10 Jelani McCoy         2008     1       6     1\n# ℹ 11,756 more rows\n\n\nTaking a closer look, we see that the players with the exceptionally high field goal percentages took very few shots. To claim that any of these player-seasons are among the best ever would strain credulity. So, in order to determine the best shooting performance, we will need to limit our data to players who took a minimum number of shots.\n\n\n\n\n\n\nSetting thresholds\n\n\n\nThe interpretation of our downstream results can be quite sensitive to the choice of threshold. If we set a very low threshold, our analysis will involve many players, including those with very limited playing time. Since we do not believe these players would be among the best shooters — otherwise, they would have received more playing time! — we may instead consider a larger, more restrictive threshold (e.g. \\(\\textrm{FGM} &gt; 1500\\)). If the threshold is too high, however, we may limit our analysis to just a small handful of players and risk overlooking impressive performances.\nBecause there is no single correct way to set a threshold, it is vitally important that you clearly explain and justify whatever choice you make.\n\n\n\nFor simplicity, we will restrict our attention to those players who attempted at least 100 field goals.\n\nseason_box %&gt;%\n  filter(FGA &gt;= 100) %&gt;%\n  arrange(desc(FGP))\n\n# A tibble: 8,847 × 13\n   Player       season   FGM   FGA   TPM   TPA   FTM   FTA minutes n_games   FGP\n   &lt;chr&gt;         &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt; &lt;dbl&gt;\n 1 Chris Ander…   2010   164   251     0     3   164   236    1693      76 0.653\n 2 Tyler Hansb…   2014   126   196     0     2   126   185     981      64 0.643\n 3 Corey Magge…   2007   519   808    13    65   519   633    2295      75 0.642\n 4 Jarron Coll…   2004   188   295     0     1   188   262    1732      81 0.637\n 5 Chris Ander…   2011    86   137     0     1    86   135     728      45 0.628\n 6 Shelden Wil…   2010    75   121     0     1    75    98     597      54 0.620\n 7 Tyson Chand…   2012   217   355     0     2   217   315    2063      62 0.611\n 8 Tyson Chand…   2010   115   190     0     0   115   157    1165      51 0.605\n 9 Leon Powe      2007   106   177     0     2   106   144     723      59 0.599\n10 Dwight Powe…   2024    63   106     1     3    63    89     836      63 0.594\n# ℹ 8,837 more rows\n# ℹ 2 more variables: TPP &lt;dbl&gt;, FTP &lt;dbl&gt;\n\n\nThe vast majority of these players are centers and forwards. Many of them do not attempt three point shots!\nWhat if we restrict our attention players who took at least 100 shots over the course of a season and took at least 50 three point shots?\n\nseason_box %&gt;%\n  filter(FGA &gt;= 100 & TPA &gt;= 50) %&gt;%\n  arrange(desc(FGP), desc(TPP)) %&gt;%\n  select(Player, season, FGP, TPP, FGA, TPA, n_games)\n\n# A tibble: 5,985 × 7\n   Player           season   FGP   TPP   FGA   TPA n_games\n   &lt;chr&gt;             &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt;\n 1 Corey Maggette     2007 0.642 0.2     808    65      75\n 2 Jimmy Butler III   2020 0.576 0.244   760   119      59\n 3 Corey Maggette     2005 0.571 0.304   986   168      66\n 4 Corey Maggette     2006 0.565 0.338   375    71      32\n 5 Kevin Martin       2009 0.564 0.415   811   277      51\n 6 Corey Maggette     2008 0.553 0.384  1000   203      70\n 7 Jimmy Butler III   2025 0.553 0.308   597   104      55\n 8 Kevin Martin       2008 0.549 0.402   914   266      61\n 9 Corey Maggette     2009 0.539 0.253   634    95      51\n10 Danilo Gallinari   2016 0.536 0.364   700   239      53\n# ℹ 5,975 more rows",
    "crumbs": [
      "Lecture 1: Boxscore Metrics"
    ]
  },
  {
    "objectID": "lectures/lecture1.html#more-nuanced-metrics",
    "href": "lectures/lecture1.html#more-nuanced-metrics",
    "title": "Lecture 1: Boxscore Metrics",
    "section": "More nuanced metrics",
    "text": "More nuanced metrics\n\nEffective Field Goal Percentage\nOne criticism of FGP is that it treats 2-point shots the same as 3-point shots. As a result, the league leader in FGP is usually a center whose shots mostly come from near the rim. Effective Field Goal Percentage (eFGP) adjusts FGP to account for the fact that a made 3-point shots is worth 50% more than a made 2-point shot. The formula for eFGP is \\[\n\\textrm{eFGP} = \\frac{\\textrm{FGM} + 0.5 \\times \\textrm{TPM}}{\\textrm{FGA}}\n\\]\nWe can create a column for in our data table using mutate\n\nseason_box \n\n# A tibble: 11,766 × 13\n   Player      season   FGM   FGA   TPM   TPA   FTM   FTA minutes n_games    FGP\n   &lt;chr&gt;        &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;  &lt;dbl&gt;\n 1 A.J. Guyton   2002    22   244    46   123    22    27     607      45 0.0902\n 2 A.J. Guyton   2003     0     4     0     1     0     0       9       2 0     \n 3 A.J. Lawson   2023     2    44    10    25     2     8     109      15 0.0455\n 4 A.J. Lawson   2024    15   121    13    50    15    23     314      42 0.124 \n 5 A.J. Lawson   2025    43   190    33   101    43    63     485      26 0.226 \n 6 A.J. Price    2010    60   354    60   174    60    75     863      56 0.169 \n 7 A.J. Price    2011    54   320    41   149    54    81     799      50 0.169 \n 8 A.J. Price    2012    28   174    26    88    28    35     567      43 0.161 \n 9 A.J. Price    2013    49   413    70   200    49    62    1276      57 0.119 \n10 A.J. Price    2014     0    46     6    22     0     2      99      28 0     \n# ℹ 11,756 more rows\n# ℹ 2 more variables: TPP &lt;dbl&gt;, FTP &lt;dbl&gt;\n\n\n\n\nTrue Shooting Percentage\nBoth field goal percentage and effective field goal percentage totally ignore free throws. One metric that accounts for all field goals, three pointers, and free throws is true shooting percentage (\\(\\textrm{TSP}\\)), whose formula is given by \\[\n\\textrm{TSP} = \\frac{\\textrm{PTS}}{2 \\times \\left(\\textrm{FGA} + (0.44 \\times \\textrm{FTA})\\right)},\n\\] where \\(\\textrm{PTS} =  \\textrm{FTM} + 2 \\times \\textrm{FGM} + \\textrm{TPM}\\) is the total number of points scored.",
    "crumbs": [
      "Lecture 1: Boxscore Metrics"
    ]
  },
  {
    "objectID": "guides/getting_started.html",
    "href": "guides/getting_started.html",
    "title": "Getting Started",
    "section": "",
    "text": "This course will make extensive use of the R programming language through the RStudio integrated development environment (IDE). Because the formal pre-requisites for this course are STAT 333 or 340, you are expected to have previous experience using the R programming language.\nThe course will also use version control (using git and GitHub) and Quarto for publishing the results of your analyses. This page contains information",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "guides/getting_started.html#computing-r-rstudio",
    "href": "guides/getting_started.html#computing-r-rstudio",
    "title": "Getting Started",
    "section": "Computing (R & RStudio)",
    "text": "Computing (R & RStudio)\n\n\n\n\n\n\nWarning\n\n\n\nI will assume fluency with basic R functionality (e.g., assignment, writing and executing scripts, saving data objects, setting environments, installing and loading packages), data manipulation with dplyr and other tidyverse packages, and visualization using either base R graphics or ggplot2. I will additionally assume some familiarity with fitting statistical models in R and interpreting their output (e.g., using lm and glm).\nIf you do not meet the formal course prerequisites and/or have not used R in a previous course, this is not the right course for you.\n\n\n\nAdditional R resources\nHaving issued that warning @prereq-warning, you will see some new R functionality in the course. As the focus is on answer sports problems, we will not spend significant classtime going over new functions, packages, or techniques. If you find that there are gaps in your R knowledge, you are expected to fill them on your own time. Here are some helpful resources\n\nR for Data Science\nData Science: A first introduction\n\n\n\nInstallation\nWhile you are expected to have used R in previous courses (see warning), I strongly recommend installing the latest version of both R and RStudio at the beginning of the course. As of the time of this writing, that is R version 4.5 and RStudio version 2025.05.\nYou can download a version of R specific to for your operating system from this website. After install R, you should download and re-install RStudio from this website.\n\n\n\n\n\n\nTip\n\n\n\nWhenever you update your version of R, you need to re-install the packages; this is a perennial source of frustration for many R users] and some good-natured humor from others (who also manually re-installs packages after every update!)\n\n\n\n\nRequired Packages\nThroughout the course, we will make extensive use of several packages in the tidyverse, primarily for data loading, pre-processing, and manipulation. We will also make extensive use of the packages glmnet, ranger, and xgboost for model fitting. We will occasionally also use ggplot2 for creating visualizations.\nAs the course progresses, we will introduce and install new package as required. For the most part, these packages will be specific to a particular sport. Every package that we will use in this class is available through either (i) the Comprehensive R Archive Network (CRAN) or (ii) a public GitHub repository maintained by the packager developer. We typically install CRAN packages using the install.packages() command. To install packages hosted on GitHub, we will use the install_github function in the devtools package (which itself is available on CRAN)\n\n\n\n\n\n\nBase packages\n\n\n\nPrior to Lecture 2, please make sure you have installed the tidyverse packages as well as devtools, ggplot2, glmnet, ranger, and xgboost.\n\ninstall.packages(c(\"devtools\", \"tidyverse\", \"ggplot2\", \"glmnet\", \"ranger\", \"xgboost\"))\n\n\n\n\n\nColorblind-friendly graphics\nI am especially partial to the Okabe-Ito color palette. Throughout the course notes, you will see snippets like\n\noi_colors &lt;-\n  palette.colors(palette = \"Okabe-Ito\")\n\nin which we explicitly create a vector holding colors from this color palette.  ## Version control (Git & GitHub)\n\n\n\nAdditional Resources",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "guides/getting_started.html#quarto",
    "href": "guides/getting_started.html#quarto",
    "title": "Getting Started",
    "section": "Quarto",
    "text": "Quarto\n\nInstallation\n\n\nPublishing",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "exercises/exercises1_boxscore.html",
    "href": "exercises/exercises1_boxscore.html",
    "title": "Constructing Advanced Metrics Using Box Score Data",
    "section": "",
    "text": "We will rely on data from the Lahman Database.\n\n\n\nif(!\"Lahman\" %in% rownames(installed.packages())){\n  message(\"Package `Lahman' not already installed. Installing now\")\n  install.packages(\"Lahman\")\n} else{\n  library(Lahman)\n}",
    "crumbs": [
      "Constructing Advanced Metrics Using Box Score Data"
    ]
  },
  {
    "objectID": "exercises/exercises1_boxscore.html#setup-installing-the-lahman-package",
    "href": "exercises/exercises1_boxscore.html#setup-installing-the-lahman-package",
    "title": "Constructing Advanced Metrics Using Box Score Data",
    "section": "",
    "text": "if(!\"Lahman\" %in% rownames(installed.packages())){\n  message(\"Package `Lahman' not already installed. Installing now\")\n  install.packages(\"Lahman\")\n} else{\n  library(Lahman)\n}",
    "crumbs": [
      "Constructing Advanced Metrics Using Box Score Data"
    ]
  },
  {
    "objectID": "exercises.html",
    "href": "exercises.html",
    "title": "Exercises",
    "section": "",
    "text": "Contains additional exercises to reproduce and extend analyses shown in lecture."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "STAT 479 (Fall 2025): Sports Analytics",
    "section": "",
    "text": "Welcome to STAT 479 (Special Topics in Statistics)! This iteration of the course will focus on sports analytics.\nLectures notes, instructions for the course project, and additional tutorials and exercises will be posted to this website. So, please bookmark this page and check it regularly throughout the course."
  },
  {
    "objectID": "index.html#course-information",
    "href": "index.html#course-information",
    "title": "STAT 479 (Fall 2025): Sports Analytics",
    "section": "Course information",
    "text": "Course information\nDescription: Illustrates the use of statistical modeling and data science techniques to derive actionable insights from sports data. Emphasizes not only technical calculation of advanced metrics but also on written and oral communication to other data scientists and to non-technical audience. Topics may include: deriving team rankings from paired competitions; measuring an individual player’s contribution to their team’s overall success; assessing player performance and team strategy in terms of expected outcomes; forecasting the impact of new rule changes using simulation; and creating new metrics using high-resolution player tracking data.\nLearning Outcomes: Throughout the course you will\n\nImplement appropriate statistical methods to assess player and team performance\nWork with play-by-play and high-resolution tracking data\nProvide constructive and actionable feedback on your peers’ analytic reports\nBuild a personal portfolio of sports data analyses\n\nLocation & Schedule: Tuesdays & Thursdays, 11:00am-12:15pm, 1524 Morgridge Hall\nInstructor & Office Hours: Sameer Deshpande (sameer.deshpande@wisc.edu). Office Hours TBA."
  },
  {
    "objectID": "guides.html",
    "href": "guides.html",
    "title": "Guides",
    "section": "",
    "text": "In this section, you will find pages containing additional background information about the methods and datasets introduced in Lecture. You will also find much more comprehensive code and guides for fitting the relevant models."
  },
  {
    "objectID": "lectures.html",
    "href": "lectures.html",
    "title": "Lecture Notes",
    "section": "",
    "text": "Lecture notes will be posted here."
  },
  {
    "objectID": "guides/plot_vertical_statsbomb.html",
    "href": "guides/plot_vertical_statsbomb.html",
    "title": "Plotting StatsBomb Data Vertically",
    "section": "",
    "text": "In Lectures 2 and 3, we built several expected goals (xg) models using data provided by StatsBomb. StatsBomb pre-processes their raw tracking data so that attacking play is oriented from left to right. I find it somewhat more aesthetically pleasing to visualize shot data vertically with the goal line on top and the half-line at the bottom.\nThis page defines a function to transform StatsBomb shot location data so that it can be plotted vertically instead of horizontally. As you continue to work with StatsBomb data, feel free to use these functions.",
    "crumbs": [
      "Plotting StatsBomb Data Vertically"
    ]
  },
  {
    "objectID": "guides/plot_vertical_statsbomb.html#overview",
    "href": "guides/plot_vertical_statsbomb.html#overview",
    "title": "Plotting StatsBomb Data Vertically",
    "section": "",
    "text": "In Lectures 2 and 3, we built several expected goals (xg) models using data provided by StatsBomb. StatsBomb pre-processes their raw tracking data so that attacking play is oriented from left to right. I find it somewhat more aesthetically pleasing to visualize shot data vertically with the goal line on top and the half-line at the bottom.\nThis page defines a function to transform StatsBomb shot location data so that it can be plotted vertically instead of horizontally. As you continue to work with StatsBomb data, feel free to use these functions.",
    "crumbs": [
      "Plotting StatsBomb Data Vertically"
    ]
  },
  {
    "objectID": "guides/plot_vertical_statsbomb.html#a-digression-on-coordinate-systems",
    "href": "guides/plot_vertical_statsbomb.html#a-digression-on-coordinate-systems",
    "title": "Plotting StatsBomb Data Vertically",
    "section": "A digression on coordinate systems",
    "text": "A digression on coordinate systems\nStatsBomb converts their raw location data to a standardized pitch of dimensions 120y x 80y. Appendix 2 of their Open Data Specification document shows the standardized pitch along with several landmarks like the penalty area and goalkeeper’s box.\n\n\n\nStatsBomb Coordinate System\n\n\nNotice that the origin (i.e., the point with coordinates c(0,0)) is in the top-left corner so that the \\(x\\) coordinate increases as you more from left to right and the \\(y\\) coordinate increases as you move from top to bottom. This coordinate system is standard for 2D computer graphics1 and is often referred to as the “left-handed” coordinate system.\nWhen we build R graphics, we typically use the more conventional “right-handed” coordinate system in which the \\(y\\) coordinates increases when we move from bottom. For instance, to create a plot region with \\(0 \\leq x \\leq 120\\) and \\(0 \\leq y \\leq 80,\\) we might use something like the following code\n\npar(mar = c(3,3,2,1), mgp = c(1.8, 0.5, 0)) # sets up margins for plot\nplot(1, type = \"n\", # signals that we want an empty plot\n     xlab = \"x\", ylab = \"y\", # labels axes\n     xlim = c(0,120), ylim = c(0,80))\n\n\n\n\n\n\n\n\nLuckily, there is a quick “fix”2 that allows us to generate plots in R using the StatsBomb coordinate system: instead of specifying ylim = c(0,80), we simply specify ylim = c(80,0). This new specification tells R that when we move from bottom-to-top, the \\(y\\) coordinate should go from 80 to 0.\n\npar(mar = c(3,3,2,1), mgp = c(1.8, 0.5, 0))\nplot(1, type = \"n\",\n     xlim = c(0, 120), ylim = c(80, 0),\n     xlab = \"x\", ylab = \"y\")\n\n\n\n\n\n\n\n\nNow that we have the coordinate system sorted, we will hard-code the coordinates several landmarks on the pitch. Doing so will help us determine an appropriate transformation of coordinates to produce a vertically oriented pitch. The main landmarks are the corners of the pitch; the corners of the left and right penalty boxes; the corners of the left and right goalkeepers’ areas; the corners of the left and right nets; the locations of the goal posts; and the half-circle.\n\n# corners of pitch\ntop_left_corner &lt;- c(0,0)\nbot_left_corner &lt;- c(0,80)\ntop_right_corner &lt;- c(120,0)\nbot_right_corner &lt;- c(120, 80)\n\n# endpoints of half-line\ntop_halfline &lt;- c(60,0)\nbot_halfline &lt;- c(60, 80)\n\n# corners of left penalty area\ntop_left_penl &lt;- c(0, 18)\nbot_left_penl &lt;- c(0,62)\ntop_right_penl &lt;- c(18,18)\nbot_right_penl &lt;- c(18,62)\n\n# corners of left goalkeeper area\ntop_left_gkl &lt;- c(0,30)\nbot_left_gkl &lt;- c(0,50)\ntop_right_gkl &lt;- c(6,30)\nbot_right_gkl &lt;- c(6,50)\n\n# left goal posts\ntop_postl &lt;- c(0,36)\nbot_postl &lt;- c(0,44)\n\n# corners of left net\ntop_left_netl &lt;- c(-2,36)\nbot_left_netl &lt;- c(-2, 44)\ntop_right_netl &lt;- c(0, 36)\nbot_right_netl &lt;- c(0,44)\n\n# corners of right penalty area\ntop_left_penr &lt;- c(102,18)\nbot_left_penr &lt;- c(102,62)\ntop_right_penr &lt;- c(120,18)\nbot_right_penr &lt;- c(120,62)\n# corners of right goal keeper's area\ntop_left_gkr &lt;- c(114,30)\nbot_left_gkr &lt;- c(114,50)\ntop_right_gkr &lt;- c(120,30)\nbot_right_gkr &lt;- c(120,50)\n# right goal posts\ntop_postl &lt;- c(120,36)\nbot_postl &lt;- c(120,44)\n# corners of left net\ntop_left_netr &lt;- c(120,36)\nbot_left_netr &lt;- c(120, 44)\ntop_right_netr &lt;- c(122, 36)\nbot_right_netr &lt;- c(122,44)\n\n# half-circles\nleft_halfcirc &lt;-\n  data.frame(x = 60 + 10*cos(seq(from = pi/2, to = 3*pi/2, length = 100)),\n             y = 40 - 10 * sin(seq(from = pi/2, to = 3*pi/2, length = 100)))\n\nright_halfcirc &lt;-\n  data.frame(x = 60 + 10*cos(seq(from =-pi/2, to = pi/2, length = 100)),\n             y = 40 - 10 * sin(seq(from = -pi/2, to = pi/2, length = 100)))\n\nWe can now add in the penalty and goalkeepers’ areas to the pitch using the rect function. This function draws a rectangle whose bottom left coordinate is c(xleft, ybottom) and whose top right coordinate is c(xright, ytop). We also add in the half line and circle\n\npar(mar = c(3,3,2,1), \n    mgp = c(1.8, 0.5, 0), \n    xpd = TRUE) # xpd allows plotting in margins\nplot(1, type = \"n\",\n     xlab = \"x\", ylab = \"y\",\n     xlim = c(0,120), ylim = c(80,0))\n# boundaries of pitch\nrect(xleft = bot_left_corner[1], ybottom = bot_left_corner[2], \n     xright = top_right_corner[1], ytop = top_right_corner[2])\n# left penalty area\nrect(xleft = bot_left_penl[1], ybottom = bot_left_penl[2],\n     xright = top_right_penl[1], ytop = top_right_penl[2])\n# left goalkeeper's area\nrect(xleft = bot_left_gkl[1], ybottom = bot_left_gkl[2],\n     xright = top_right_gkl[1], ytop = top_right_gkl[2])\n# left net\nrect(xleft = bot_left_netl[1], ybottom = bot_left_netl[2],\n     xright = top_right_netl[1], ytop = top_right_netl[2])\n\n# right penalty area\nrect(xleft = bot_left_penr[1], ybottom = bot_left_penr[2],\n     xright = top_right_penr[1], ytop = top_right_penr[2])\n# right goalkeeper's area\nrect(xleft = bot_left_gkr[1], ybottom = bot_left_gkr[2],\n     xright = top_right_gkr[1], ytop = top_right_gkr[2])\n# right net\nrect(xleft = bot_left_netr[1], ybottom = bot_left_netr[2],\n     xright = top_right_netr[1], ytop = top_right_netr[2])\n# half-line\nlines(x = c(top_halfline[1], bot_halfline[1]),\n      y = c(top_halfline[2], bot_halfline[2]))\n# left half-circle \nlines(x = left_halfcirc$x, y = left_halfcirc$y)\n# right half-circle\nlines(x = right_halfcirc$x, y = right_halfcirc$y)",
    "crumbs": [
      "Plotting StatsBomb Data Vertically"
    ]
  },
  {
    "objectID": "guides/plot_vertical_statsbomb.html#translation-and-rotation",
    "href": "guides/plot_vertical_statsbomb.html#translation-and-rotation",
    "title": "Plotting StatsBomb Data Vertically",
    "section": "Translation and Rotation",
    "text": "Translation and Rotation\nWe will form a vertical pitch layout by composing the following three transformations:\n\nTranslate the pitch so the origin is at mid-field, which is located at \\((60,40).\\) Mathematically, the transformation is \\((x,y) \\rightarrow (x-60, y - 40)\\)\nRotate the pitch so that (i) the bottom right corner goes to the top right; (ii) the top right corner goes to the top left; (iii) the top left corner goes to the bottom left; and (iv) the bottom left corner goes to the bottom right. Mathematically, the transformation is \\((x,y) \\rightarrow (y, -x)\\)3.\nTranslate the rotated frame so that the origin is in the top left corner. Mathematically, the transformation is \\((x,y) \\rightarrow (x+40,y+60).\\)\n\nPutting these steps together, we have the transformation \\[\n(x,y) \\rightarrow (x-60, y-40) \\rightarrow (y-40, 60-x) \\rightarrow (y,120-x)\n\\] It will be useful to define functions for these transformations\n\ntransform_x &lt;- function(x,y){return(y)}\ntransform_y &lt;- function(x,y){return(120-x)}\n\nRecall that the function rect draws a rectangle using the coordinates of its bottom left and top right corners. We can compute the coordinates of the bottom left (resp. top right) corner of a rectangle in a vertical orientation by transforming the coordinates of the top left (resp. bottom right) corners of a rectangle in the original horizontal orientation.\n\npar(mar = c(3,3,2,1), mgp = c(1.8, 0.5, 0))\nplot(1, type = \"n\",\n     xlim = c(0, 80), ylim = c(120,0), # note the different limits!\n     xlab = \"x\", ylab = \"y\")\n# boundaries of pitch\nrect(xleft = transform_x(top_left_corner[1], top_left_corner[2]),\n     ybottom = transform_y(top_left_corner[1], top_left_corner[2]),\n     xright = transform_x(bot_right_corner[1], bot_right_corner[2]),\n     ytop = transform_y(bot_right_corner[1], bot_right_corner[2]))\n# original left penalty area now on bottom\nrect(xleft = transform_x(top_left_penl[1], top_left_penl[2]),\n     ybottom = transform_y(top_left_penl[1], top_left_penl[2]),\n     xright = transform_x(bot_right_penl[1], bot_right_penl[2]),\n     ytop = transform_y(bot_right_penl[1], bot_right_penl[2]))\n# original left goalkeeper's area now on bottom\nrect(xleft = transform_x(top_left_gkl[1], top_left_gkl[2]),\n     ybottom = transform_y(top_left_gkl[1], top_left_gkl[2]),\n     xright = transform_x(bot_right_gkl[1], bot_right_gkl[2]),\n     ytop = transform_y(bot_right_gkl[1], bot_right_gkl[2]))\n# original left net now on bottom\nrect(xleft = transform_x(top_left_netl[1], top_left_netl[2]),\n     ybottom = transform_y(top_left_netl[1], top_left_netl[2]),\n     xright = transform_x(bot_right_netl[1], bot_right_netl[2]),\n     ytop = transform_y(bot_right_netl[1], bot_right_netl[2]))\n\n# original right penalty area now on top\nrect(xleft = transform_x(top_left_penr[1], top_left_penr[2]),\n     ybottom = transform_y(top_left_penr[1], top_left_penr[2]),\n     xright = transform_x(bot_right_penr[1], bot_right_penr[2]),\n     ytop = transform_y(bot_right_penr[1], bot_right_penr[2]))\n# original right goalkeeper's area now on top\nrect(xleft = transform_x(top_left_gkr[1], top_left_gkr[2]),\n     ybottom = transform_y(top_left_gkr[1], top_left_gkr[2]),\n     xright = transform_x(bot_right_gkr[1], bot_right_gkr[2]),\n     ytop = transform_y(bot_right_gkr[1], bot_right_gkr[2]))\n# original right net now on bottom\nrect(xleft = transform_x(top_left_netr[1], top_left_netr[2]),\n     ybottom = transform_y(top_left_netr[1], top_left_netr[2]),\n     xright = transform_x(bot_right_netr[1], bot_right_netr[2]),\n     ytop = transform_y(bot_right_netr[1], bot_right_netr[2]))\n\n# half-line\nlines(x = transform_x( c(top_halfline[1], bot_halfline[1]), c(top_halfline[2], bot_halfline[2])),\n      y = transform_y( c(top_halfline[1], bot_halfline[1]), c(top_halfline[2], bot_halfline[2])))\n# original left half-circle now on bottom\nlines(x = transform_x(left_halfcirc$x, left_halfcirc$y),\n      y = transform_y(left_halfcirc$x, left_halfcirc$y))\n# original right half-circle now on top\nlines(x = transform_x(right_halfcirc$x, right_halfcirc$y),\n      y = transform_y(right_halfcirc$x, right_halfcirc$y))\n\n\n\n\n\n\n\n\nFor convenience, we can write a function that plots either the full pitch or the attacking in either the horizontal or vertical orientation. The function plot_pitch has two arguments:\n\nhalf: Set half = TRUE to plot the attacking half and half = FALSE to plot the full pitch. Default is TRUE\nvertical: Set vertical = TRUE to plot in a vertical orientation and vertical = FALSE to plot in a horizontal orientation. Default is TRUE\n\nYou can download an R script implementing this function from this link. If you save that script in your course or project repository, you can source it as needed. You can also unfold the next code block to see how the function plot_pitch is implemented.\n\n\nCode\nplot_pitch &lt;- function(half = TRUE, vertical = TRUE){\n  par(mar = c(2,1,4,1), # lower left & right margins but increase top margin\n      mgp = c(1.8, 0.5, 0), \n      xpd = TRUE) # allows plotting in the margin\n  if(vertical){\n    # plot vertical pitch\n    if(half){\n      # only plot the attacking half\n      plot(1, type = \"n\",\n           xlim = c(0,80), ylim = c(60,0),\n           xaxt = \"n\", yaxt = \"n\", # suppresses axis marks\n           xlab = NA, ylab = NA, # suppress labels\n           bty = \"n\") # suppresses the bounding box\n      # pitch\n      rect(xleft = transform_x(top_halfline[1], top_halfline[2]),\n           ybottom = transform_y(top_halfline[1], top_halfline[2]),\n           xright = transform_x(bot_right_corner[1], bot_right_corner[2]),\n           ytop = transform_y(bot_right_corner[1], bot_right_corner[2]))\n      # original right penalty area now on top\n      rect(xleft = transform_x(top_left_penr[1], top_left_penr[2]),\n           ybottom = transform_y(top_left_penr[1], top_left_penr[2]),\n           xright = transform_x(bot_right_penr[1], bot_right_penr[2]),\n           ytop = transform_y(bot_right_penr[1], bot_right_penr[2]))\n      # original right goalkeeper's area now on top\n      rect(xleft = transform_x(top_left_gkr[1], top_left_gkr[2]),\n           ybottom = transform_y(top_left_gkr[1], top_left_gkr[2]),\n           xright = transform_x(bot_right_gkr[1], bot_right_gkr[2]),\n           ytop = transform_y(bot_right_gkr[1], bot_right_gkr[2]))\n      # original right net now on top\n      rect(xleft = transform_x(top_left_netr[1], top_left_netr[2]),\n           ybottom = transform_y(top_left_netr[1], top_left_netr[2]),\n           xright = transform_x(bot_right_netr[1], bot_right_netr[2]),\n           ytop = transform_y(bot_right_netr[1], bot_right_netr[2]))\n      # half-circle\n      lines(x = transform_x(right_halfcirc$x, right_halfcirc$y),\n            y = transform_y(right_halfcirc$x, right_halfcirc$y))\n    } else{\n      # plot the full field\n      plot(1, type = \"n\",\n           xlim = c(0, 80), ylim = c(120,0), \n           xaxt = \"n\", yaxt = \"n\", # suppresses axis marks\n           xlab = NA, ylab = NA, # suppress labels\n           bty = \"n\") # suppresses the bounding box\n      # boundaries of pitch\n      rect(xleft = transform_x(top_left_corner[1], top_left_corner[2]),\n           ybottom = transform_y(top_left_corner[1], top_left_corner[2]),\n           xright = transform_x(bot_right_corner[1], bot_right_corner[2]),\n           ytop = transform_y(bot_right_corner[1], bot_right_corner[2]))\n      # original left penalty area now on bottom\n      rect(xleft = transform_x(top_left_penl[1], top_left_penl[2]),\n           ybottom = transform_y(top_left_penl[1], top_left_penl[2]),\n           xright = transform_x(bot_right_penl[1], bot_right_penl[2]),\n           ytop = transform_y(bot_right_penl[1], bot_right_penl[2]))\n      # original left goalkeeper's area now on bottom\n      rect(xleft = transform_x(top_left_gkl[1], top_left_gkl[2]),\n           ybottom = transform_y(top_left_gkl[1], top_left_gkl[2]),\n           xright = transform_x(bot_right_gkl[1], bot_right_gkl[2]),\n           ytop = transform_y(bot_right_gkl[1], bot_right_gkl[2]))\n      # original left net now on bottom\n      rect(xleft = transform_x(top_left_netl[1], top_left_netl[2]),\n           ybottom = transform_y(top_left_netl[1], top_left_netl[2]),\n           xright = transform_x(bot_right_netl[1], bot_right_netl[2]),\n           ytop = transform_y(bot_right_netl[1], bot_right_netl[2]))\n      # original right penalty area now on top\n      rect(xleft = transform_x(top_left_penr[1], top_left_penr[2]),\n           ybottom = transform_y(top_left_penr[1], top_left_penr[2]),\n           xright = transform_x(bot_right_penr[1], bot_right_penr[2]),\n           ytop = transform_y(bot_right_penr[1], bot_right_penr[2]))\n\n      # original right goalkeeper's area now on top\n      rect(xleft = transform_x(top_left_gkr[1], top_left_gkr[2]),\n           ybottom = transform_y(top_left_gkr[1], top_left_gkr[2]),\n           xright = transform_x(bot_right_gkr[1], bot_right_gkr[2]),\n           ytop = transform_y(bot_right_gkr[1], bot_right_gkr[2]))\n      # original right net now on bottom\n      rect(xleft = transform_x(top_left_netr[1], top_left_netr[2]),\n           ybottom = transform_y(top_left_netr[1], top_left_netr[2]),\n           xright = transform_x(bot_right_netr[1], bot_right_netr[2]),\n           ytop = transform_y(bot_right_netr[1], bot_right_netr[2]))\n      # half-line\n      lines(x = transform_x( c(top_halfline[1], bot_halfline[1]), c(top_halfline[2],bot_halfline[2])),\n            y = transform_y( c(top_halfline[1], bot_halfline[1]), c(top_halfline[2], bot_halfline[2])))\n      # original left half-circle now on bottom\n      lines(x = transform_x(left_halfcirc$x, left_halfcirc$y),\n            y = transform_y(left_halfcirc$x, left_halfcirc$y))\n      # original right half-circle now on top\n      lines(x = transform_x(right_halfcirc$x, right_halfcirc$y),\n            y = transform_y(right_halfcirc$x, right_halfcirc$y))\n    }# closes if/else checking whether to plot attacking half\n  } else{\n    # plot horizontal pitch\n    if(half){\n      plot(1, type = \"n\",\n           xlim = c(60,120), ylim = c(80, 0),\n           xaxt = \"n\", yaxt = \"n\", # suppresses axis marks\n           xlab = NA, ylab = NA,# suppresses labels\n           bty = \"n\") # suppresses the bounding box\n      # boundaries of attacking half\n      rect(xleft = bot_halfline[1], ybottom = bot_halfline[2], \n           xright = top_right_corner[1], ytop = top_right_corner[2])\n      # right penalty area\n      rect(xleft = bot_left_penr[1], ybottom = bot_left_penr[2],\n           xright = top_right_penr[1], ytop = top_right_penr[2])\n      # right goalkeeper's area\n      rect(xleft = bot_left_gkr[1], ybottom = bot_left_gkr[2],\n           xright = top_right_gkr[1], ytop = top_right_gkr[2])\n      # right net\n      rect(xleft = bot_left_netr[1], ybottom = bot_left_netr[2],\n           xright = top_right_netr[1], ytop = top_right_netr[2])\n      # right half-circle\n      lines(x = right_halfcirc$x, y = right_halfcirc$y)\n    } else{\n      plot(1, type = \"n\",\n           xlim = c(0,120), ylim = c(80,0),\n           xaxt = \"n\", yaxt = \"n\", # suppresses axis marks\n           xlab = NA, ylab = NA, # suppress labels\n           bty = \"n\") # suppresses the bounding box\n      # boundaries of pitch\n      rect(xleft = bot_left_corner[1], ybottom = bot_left_corner[2], \n           xright = top_right_corner[1], ytop = top_right_corner[2])\n      # left penalty area\n      rect(xleft = bot_left_penl[1], ybottom = bot_left_penl[2],\n           xright = top_right_penl[1], ytop = top_right_penl[2])\n      # left goalkeeper's area\n      rect(xleft = bot_left_gkl[1], ybottom = bot_left_gkl[2],\n           xright = top_right_gkl[1], ytop = top_right_gkl[2])\n      # left net\n      rect(xleft = bot_left_netl[1], ybottom = bot_left_netl[2],\n           xright = top_right_netl[1], ytop = top_right_netl[2])\n      # right penalty area\n      rect(xleft = bot_left_penr[1], ybottom = bot_left_penr[2],\n           xright = top_right_penr[1], ytop = top_right_penr[2])\n      # right goalkeeper's area\n      rect(xleft = bot_left_gkr[1], ybottom = bot_left_gkr[2],\n           xright = top_right_gkr[1], ytop = top_right_gkr[2])\n      # right net\n      rect(xleft = bot_left_netr[1], ybottom = bot_left_netr[2],\n           xright = top_right_netr[1], ytop = top_right_netr[2])\n      # half-line\n      lines(x = c(top_halfline[1], bot_halfline[1]),\n            y = c(top_halfline[2], bot_halfline[2]))\n      # left half-circle \n      lines(x = left_halfcirc$x, y = left_halfcirc$y)\n      # right half-circle\n      lines(x = right_halfcirc$x, y = right_halfcirc$y)\n    }\n  } # closes if/else checking whether to plot horizontally or vertically\n  \n}",
    "crumbs": [
      "Plotting StatsBomb Data Vertically"
    ]
  },
  {
    "objectID": "guides/plot_vertical_statsbomb.html#example-visualizing-beth-meads-goals-at-euro-2022",
    "href": "guides/plot_vertical_statsbomb.html#example-visualizing-beth-meads-goals-at-euro-2022",
    "title": "Plotting StatsBomb Data Vertically",
    "section": "Example: Visualizing Beth Mead’s goals at EURO 2022",
    "text": "Example: Visualizing Beth Mead’s goals at EURO 2022\nWe’ll use our new function plot_pitch() to illustrate all 5 of Beth Mead’s goals at EURO 2022.\n\nlibrary(tidyverse)\noi_colors &lt;- \n  palette.colors(palette = \"Okabe-Ito\")\n\nThe code in the next block, which is very similar to that used in Lecture 2, does the following things:\n\nLoads & preprocesses the event data from EURO 2022 (competition_id = 53 and season_id = 106)\nFilters to all goals scored by Beth Mead.\nSelects only the starting and ending locations of the shots (in the horizontal orientation)\nComputes the starting and ending coordinates in the vertical orientation of each shot\n\nWe will first plot the goals on the full horizontal pitch\n\nplot_pitch(half = FALSE, vertical = FALSE)\nfor(i in 1:nrow(mead_goals)){\n  lines(x = c(mead_goals$location.x[i], mead_goals$shot.end_location.x[i]),\n        y = c(mead_goals$location.y[i], mead_goals$shot.end_location.y[i]),\n         col = oi_colors[i+1])\n}\nmtext(\"Beth Mead Goals (EURO 2022)\", side = 3, line = 1)\nmtext(\"Created with free data from StatsBomb\\n https://github.com/statsbomb/open-data\",\n      side = 1, line = 1)\n\n\n\n\n\n\n\n\nAnd here are the same goals but in the attacking half in a vertical orientation\n\nplot_pitch(half = TRUE, vertical = TRUE)\nfor(i in 1:nrow(mead_goals)){\n  lines(x = c(mead_goals$vert_location.x[i], mead_goals$vert_shot.end_location.x[i]),\n        y = c(mead_goals$vert_location.y[i], mead_goals$vert_shot.end_location.y[i]),\n         col = oi_colors[i+1])\n}\nmtext(\"Beth Mead Goals (EURO 2022)\", side = 3, line = 1)\nmtext(\"Created with free data from StatsBomb\\n https://github.com/statsbomb/open-data\",\n      side = 1, line = 1)",
    "crumbs": [
      "Plotting StatsBomb Data Vertically"
    ]
  },
  {
    "objectID": "guides/plot_vertical_statsbomb.html#footnotes",
    "href": "guides/plot_vertical_statsbomb.html#footnotes",
    "title": "Plotting StatsBomb Data Vertically",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee here for the gory details or check out the Wikipedia entry on 2D graphics.↩︎\nI found this solution here after Googling “R change origin top left”.↩︎\nCounter-clockwise rotations in the usual right-handed coordinate system (with \\(y\\) increasing from bottom-to-top) are clockwise rotations in the left-handed coordinate system we are using, in which \\(y\\) increases from top-to-bottom. We want to rotate 90 degrees counter-clockwise in the right-handed system, which is equivalent to a 270 degree clockwise rotation in the left-handed system. See this Wikipedia entry for more details.↩︎",
    "crumbs": [
      "Plotting StatsBomb Data Vertically"
    ]
  },
  {
    "objectID": "lectures/lecture8.html",
    "href": "lectures/lecture8.html",
    "title": "Lecture 8: Pitch Framing & Multi-level modeling",
    "section": "",
    "text": "library(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors",
    "crumbs": [
      "Lecture 8: Pitch Framing & Multi-level modeling"
    ]
  },
  {
    "objectID": "lectures/lecture3.html",
    "href": "lectures/lecture3.html",
    "title": "Lecture 3: Building our own XG model",
    "section": "",
    "text": "We will start with logistic regression and then move on to regression trees and ensembles to steadily improve our\nLogistic regression\nRandom forests",
    "crumbs": [
      "Lecture 3: Building our own XG model"
    ]
  },
  {
    "objectID": "lectures/lecture3.html#overview",
    "href": "lectures/lecture3.html#overview",
    "title": "Lecture 3: Building our own XG model",
    "section": "",
    "text": "We will start with logistic regression and then move on to regression trees and ensembles to steadily improve our\nLogistic regression\nRandom forests",
    "crumbs": [
      "Lecture 3: Building our own XG model"
    ]
  },
  {
    "objectID": "lectures/lecture3.html#an-initial-xg-model",
    "href": "lectures/lecture3.html#an-initial-xg-model",
    "title": "Lecture 3: Building our own XG model",
    "section": "An initial XG model",
    "text": "An initial XG model\nIntuitively, we expect shots taken very close to the goal to have larger xG than shots taken very far from the goal\n\nHandcrafting features\n\n\nAdding interactions\nIt may not just be distance and body part but their interaction;",
    "crumbs": [
      "Lecture 3: Building our own XG model"
    ]
  },
  {
    "objectID": "lectures/lecture3.html#tree-based-models",
    "href": "lectures/lecture3.html#tree-based-models",
    "title": "Lecture 3: Building our own XG model",
    "section": "Tree-based models",
    "text": "Tree-based models\nAdding more covariates and interactions becomes extremely tricky. Methods based on regression trees are a convenient way to overcome this limitation.\n\nIllustration",
    "crumbs": [
      "Lecture 3: Building our own XG model"
    ]
  },
  {
    "objectID": "lectures/lecture3.html#gk-metrics",
    "href": "lectures/lecture3.html#gk-metrics",
    "title": "Lecture 3: Building our own XG model",
    "section": "GK metrics",
    "text": "GK metrics\nTo what extent does a keeper affect XG? To answer this this, we can fit two XG models. One with keeper information and one without. We can then compare the two different XG values Consider a model that includes goal keeper position one without.",
    "crumbs": [
      "Lecture 3: Building our own XG model"
    ]
  },
  {
    "objectID": "lectures/lecture5.html#the-probability-of-making-an-out",
    "href": "lectures/lecture5.html#the-probability-of-making-an-out",
    "title": "Lecture 5: Wins Above Replacement II",
    "section": "The probability of making an out",
    "text": "The probability of making an out\nHow difficult is a ball-in-play (BIP) to field? Intuitively, if the pitcher gives up a home run, the remaining fielders should not get any blame. And if a fielder makes an error, the pitcher should not get any blame.\nOf the total \\(-\\delta_{i}\\) we need to",
    "crumbs": [
      "Lecture 5: Wins Above Replacement II"
    ]
  },
  {
    "objectID": "lectures/lecture5.html#fielding-run-values",
    "href": "lectures/lecture5.html#fielding-run-values",
    "title": "Lecture 5: Wins Above Replacement II",
    "section": "Fielding run values",
    "text": "Fielding run values\n\n\nPitching run values",
    "crumbs": [
      "Lecture 5: Wins Above Replacement II"
    ]
  },
  {
    "objectID": "lectures/lecture5.html#replacement-level",
    "href": "lectures/lecture5.html#replacement-level",
    "title": "Lecture 5: Wins Above Replacement II",
    "section": "Replacement Level",
    "text": "Replacement Level\nMost teams carry 13 position players and 12 pitchers, we designate the \\(30 \\times 13 = 390\\) position players with the most PAs to be the non-replacement players. Everyone else is replacement level\nWe can compute the average RAA for all replacement level players. Then we look at (RAA_p - RAA_shadow)/10 to be WAR",
    "crumbs": [
      "Lecture 5: Wins Above Replacement II"
    ]
  }
]